【基础语法】


print('''
    へ　　　　　／|
　　/＼7　　　 ∠＿/
　 /　│　　 ／　／
　│　Z ＿,＜　／　　 /`ヽ
　│　　　　　ヽ　　 /　　〉
　 Y　　　　　`　 /　　/
　ｲ●　､　●　　⊂⊃〈　　/
　()　 へ　　　　|　＼〈
　　>ｰ ､_　 ィ　 │ ／／
　 / へ　　 /　ﾉ＜| ＼＼
　 ヽ_ﾉ　　(_／　 │／／
　　7　　　　　　　|／
　　＞―r￣￣`ｰ―＿
''')




________________________________________________________________________________________________ 

A = input('输入一个你错过的人：')     
B = input('输入你最想对ta说的话：')   
C = input('输入一个时长(比如三分钟)：')

print('曾经有一份真挚的爱情放在我面前，ta的名字是' + A)
print('可我没有珍惜，如果上天能再给我一次机会，我会对他说三个字'+ B)
print('如果非要给这句话加上一个期限，我希望是'+ C)



________________________________________________________________________________________________



number1  = 1
number2 = 2
unit1 = '人'
unit2 = '眼'
line1 = '我编程累'
line2 = '是bug相随'
sentence1 = '碎掉的节操满地堆'
sentence2 = '我只求今日能早归'

print(str(number1) + unit1 + line1 + sentence1)
print(str(number2) + unit2 + line2 + sentence2)



________________________________________________________________________________________________




slogan = '脸黑怪我咯'
number = '7.8'
unit = '张'
sentence = '蓝票一个SSR都没有'
word = slogan + str(int(float(number))) + sentence
print(word)



________________________________________________________________________________________________


print('《红豆》王维\n红豆生南国, 春来发几枝。\n愿君多采撷, 此物最相思。')


________________________________________________________________________________________________


a = input('请输入你每天花在手机上的娱乐时间：')
b = int(a) * 7
print('您一周花在手机上的娱乐时间总共是'+str(b)+'小时')



________________________________________________________________________________________________


#以下为答案示例(salary为多少都是对的)
salary = 200
if salary <= 500:
    #条件：如果工资小于等于500
    print('欢迎进入史塔克穷人帮前三名')
    if salary <= 100:
        print('恭喜您荣获“美元队长”称号！')
    else:
        print('请找弗瑞队长加薪')
elif 500 < salary <= 1000:
    print('祝贺您至少可以温饱了。')
elif salary > 1000:
    print('经济危机都难不倒您！')
    if 1000 < salary <= 20000:
        print('您快比钢铁侠有钱了！')
    else:
        print('您是不是来自于瓦坎达国？')
print('程序结束')





________________________________________________________________________________________________


t = int(input('派大星今天吃了多少个蟹黄堡'))
if t > 40:
    print('派大星给海绵宝宝100块')
else:
    print('海绵宝宝给派大星100块')

________________________________________________________________________________________________


now = input('你们之前的感情有进入暧昧期了吗？回答有/没有：')

if now =='没有':
    print('进度条还不太够，再等等吧。')
else:
    p1 = input('你希望你们的关系再往前一步吗？回答想/不想：')
    if p1=='不想':
        print('那还是做朋友吧。')
    else:
        p2 = input('那个人呢，ta想吗？回答想/不想：')
        if p2=='不想':
            print('恭喜你！获得好人卡*1')
        else:
            print('恭喜你们！在一起！')



now = input('你们之前的感情有进入暧昧期了吗？回答有/没有：')
p1 = input('你希望你们的关系再往前一步吗？回答想/不想：')
p2 = input('那个人呢，ta想吗？回答想/不想：')

if now =='没有':
    print('进度条还不太够，再等等吧。')
elif p1=='不想':
    print('那还是做朋友吧。')
elif p2=='不想':
    print('恭喜你！获得好人卡*1')
else:
    print('恭喜你们！在一起！')




#提示是为了让大家更好写出代码，其实更优雅和符合逻辑的代码是这样的：

if input('你们之前的感情有进入暧昧期了吗？回答有/没有：') =='没有':
    print('进度条还不太够，再等等吧。')
elif input('你希望你们的关系再往前一步吗？回答想/不想：')=='不想':
    print('那还是做朋友吧。')
elif input('那个人呢，ta想吗？回答想/不想：')=='不想':
    print('恭喜你！获得好人卡*1')
else:
    print('恭喜你们！在一起！')




#我们是可以在写出代码后再进行优化的。

now = input('你们之前的感情有进入暧昧期了吗？回答有/没有：')
if now =='没有':
    exit('进度条还不太够，再等等吧。')
p1 = input('你希望你们的关系再往前一步吗？回答想/不想：')
if p1=='不想':
    exit('那还是做朋友吧。')
p2 = input('那个人呢，ta想吗？回答想/不想：')
if p2=='不想':
    exit('恭喜你！获得好人卡*1')
else:
    print('恭喜你们！在一起！')
#第三种答案




now = input('你们之前的感情有进入暧昧期了吗？回答有/没有：')

if now =='没有':
    print('进度条还不太够，再等等吧。')
else:
    p1 = input('你希望你们的关系再往前一步吗？回答想/不想：')
    if p1=='不想':
        print('那还是做朋友吧。')
    else:
        p2 = input('那个人呢，ta想吗？回答想/不想：')
        if p2=='不想':
            print('恭喜你！获得好人卡*1')
        else:
            print('恭喜你们！在一起！')
#第四种答案




________________________________________________________________________________________________



a = float(input('请输入你的体重(kg)：'))
b = float(input('请输入你的身高(m)：'))
bmi = a/(b*b)
if bmi >= 28.0:
    print('肥胖')
elif bmi >= 24.0:
    print('过重')
elif bmi >= 18.5:
    print('正常')
else:
    print('过轻')


________________________________________________________________________________________________


name = input('为哈利·波特的猫头鹰起个名字：')
print('哈利·波特的猫头鹰叫做' + name)

________________________________________________________________________________________________


number = int(input('请输入罗恩吃的巧克力数量：'))
#int将其转换为整数，之后好进行大小的比较
if number > 10:
    print('罗恩要给哈利100块')
else:
    print('哈利就给罗恩100块')


________________________________________________________________________________________________



chioce = input('您好，欢迎古灵阁，请问需要帮助吗？需要or不需要？')
if chioce == '需要':
    number = input('请问您需要什么帮助呢？1 存取款；2 货币兑换；3 咨询')
    if number == '2':
        print('金加隆和人民币的兑换率为1:51.3，即一金加隆=51.3人民币')
        print('请问您需要兑换多少金加隆呢？')
        money = input('请输入你需要兑换的金加隆')
        print('好的，我知道了，您需要兑换' + money + '金加隆。')
        print('那么，您需要付给我'+str(int(float(money)*51.3))+'人民币。')
    elif number == '1':
        print('请到存取款窗口办理')
    elif number == '3':
        print('请到咨询窗口咨询')
    else:
        print('输入错误，没有你需要的服务')

elif chioce == '不需要':
    print('好的，再见')

else:
    print('输入错误')



________________________________________________________________________________________________




题目讲解
第一步：取出字典中键为3对应的值（dict1[3]），即['love','hatred','envy']
第二步：再取出列表['love','hatred','envy']中的第一个元素（dict1[3][0]）



dict1 = {1:['cake','scone','puff'],2:['London','Bristol','Bath'],3:['love','hatred','envy']}
print(dict1[3][0])

________________________________________________________________________________________________


第一步：元组和列表都是序列,提取的方式也是偏移量，如 tuple1[1]、tuple1[1:]。
第二步：先取出列表中的第二个元素中的（list2[1]）
第三步：然后在第二个元素的基础上在去取值，即list2[1][1]
注：（元组和列表的取值方式是相同的）



tuple1 = ('A','B')
list2 = [('A','B'),('C','D'),('E','F')]

print(tuple1[0])
print(list2[1][1])



________________________________________________________________________________________________



练习目标：
在层层嵌套的各种数据类型中，准确地提取出你需要的数据。<br>
练习要求：
在未来世界里，一个新建的童话镇吸引了不少人入住。
不过，在人群里隐藏着一只狼，会威胁大家的安全。
童话镇的镇长希望你能找到它，并揭发其身份。
用程序语言就是说：列表中有个字符串是“狼”，将其打印出来吧。



townee = [
    {'海底王国':['小美人鱼''海之王''小美人鱼的祖母''五位姐姐'],'上层世界':['王子','邻国公主']},
    '丑小鸭','坚定的锡兵','睡美人','青蛙王子',
    [{'主角':'小红帽','配角1':'外婆','配角2':'猎人'},{'反面角色':'狼'}]
    ]

print(townee[5][1]['反面角色'])


________________________________________________________________________________________________




# while 循环
n = 0
while n < 7:
    n = n+1
    if n != 4:  # 当num != 4，执行打印语句；等于4时不打印。
        print(n)



# for 循环
for num in range(1,8):  # 为同时能运行两个循环，新取参数 num。
    if num != 4:  # 当num != 4，执行打印语句；等于4时不打印。
        print(num)



________________________________________________________________________________________________


小明、小红、小刚是同班同学，且坐在同一排，分别坐在第一位、第二位、第三位。
由于他们的身高都差不多，所以，老师计划让他们三个轮流坐在第一位。
每次换座位的时候，第一位变第三位，后面两位都往前一位。
方法1：append()函数
 
students = ['小明','小红','小刚']
for i in range(3):
    student1 = students[0]
    students = students[1:]
    students.append(student1)
    print(students)





________________________________________________________________________________________________



pop()函数
我们先介绍一下列表中的pop()函数，用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。
可以将其理解为提取和删除的融合：①提取：取到元素，对列表没有影响；②删除：删除列表的元素。
而移除，则是同时做到取到元素，并且删除列表中的元素。


students = ['小明','小红','小刚']
for i in range(3):
    student1 = students.pop(0)
    students.append(student1)
    print(students)



________________________________________________________________________________________________


1.开启循环，两人分别选择
首先，我们需要知道两个囚徒各自的选择（input*2）。
 
2.循环当中，有判断和跳出
两个囚徒的选择，会有四种不同的结果。所以，可以用'if...elif...else'。
判决提示：
若两人都认罪，则两人各判10年；
若一个认罪一个抵赖，则认罪的人判1年，抵赖的人判20年；
若两人都抵赖，则各判3年——这种情况下跳出循环。




while True:
    a = input('A，你认罪吗？请回答认罪或者不认')
    b = input('B，你认罪吗？请回答认罪或者不认')




while True: 
    a = input('A，你认罪吗？请回答认罪或者不认')
    b = input('B，你认罪吗？请回答认罪或者不认')
    if a == '认罪' and b == '认罪':
        print('两人都得判10年，唉')
    elif a == '不认' and b == '认罪':
        print('A判20年，B判1年，唉')
    elif a == '认罪' and b == '不认':
        print('A判1年，B判20年')
    else:
        print('都判3年，太棒了')
        break  # 当满足开头提到的条件时，跳出循环。



________________________________________________________________________________________________



上一个练习，我们将“囚徒困境”写成了代码，让程序收集两名囚犯的认罪情况，进而决定他们的判决：
两人都认罪，则各判10年；一个认罪一个抵赖，则前者判1年，后者判20年；两人都抵赖，各判3年。只有两人都不认罪，程序才会停止。
现在有一个社会学家，在不同的人群中做这个实验，一旦遇到都不认罪的情况，就停止该人群中的实验。
同时，他希望程序能记录每一对实验者的选择，以及记录第几对实验者都选择不认罪。请你帮帮他吧。


几个提示：
为了记录每一对实验者的选择，需要用一个可拓展的“容器”来存放这些数据；
为了记录是第几对实验者做了最优选择，需要用一个变量来计数；
为了将每一对实验者的选择再打印出来，需要写一个循环。
在打印的那个循环里，需要留意列表是从0开始计数的。



n = 0
list_answer = []


while True:
    n += 1
    a = input('A，你认罪吗？请回答认罪或者不认：')
    b = input('B，你认罪吗？请回答认罪或者不认：')
    list_answer.append([a,b])
    if a == '认罪' and b == '认罪':
        print('两人都得判10年，唉')
    elif a == '不认' and b == '认罪':
        print('A判20年，B判1年，唉')
    elif a == '认罪' and b == '不认':
        print('A判1年，B判20年')
    else:
        print('都判3年，太棒了')
        break

print('第' + str(n) + '对实验者选了最优解。')

for i in range(n):
    print('第' + str(i+1) + '对实验者的选择是：' + str(list_answer[i]))






________________________________________________________________________________________________


下面，会将电影的影片名和主演放在字典里，如`movie = {'妖猫传':['黄轩','染谷将太']}`。
需要你补充一些代码，让其他人只要输入演员名，就打印出：××出演了电影××。
 
对该练习完整的提示：
1.先用for...in...遍历字典，把键（即电影名）取出来；
2.再用字典的键把字典里的值（即包含主演名字的列表）取出来；
3.最后用if A in B 作为条件判断A在不在B中，即输入的演员名在不在这个列表中。如果在这个列表中，就打印出××出演了电影××。




movies = {
'妖猫传':['黄轩','染谷将太'],
'无问西东':['章子怡','王力宏','祖峰'],
'超时空同居':['雷佳音','佟丽娅'],
}


actor = input('你想查询哪个演员？')
for  movie in movies:
    actors = movies[movie]
    if actor in actors:
        print(actor + '出演了电影' + movie)



________________________________________________________________________________________________



要达成目标，有两种方案：
1.while True+break：
开启一个无限循环，设定跳出条件。
当得到肯定回复时，继续运行；当得到否定回复时，运行break，停止循环，退出游戏。
 
2.while 变量名+变量名的布尔值判断：
在开头设某变量的布尔值为True，input后开启判断变量的布尔值是否改变。
当得到肯定回复时，while True，继续运行；当得到否定回复时，while False，停止循环，退出游戏。下面，我们先用较简单的代码来体会一下这两种方案。
 
方案1：while True+break
开启一个无限循环，设定跳出条件。
当得到肯定回复时，继续运行；当得到否定回复时，运行break，停止循环，退出游戏。
 
方案2：while 变量名+变量名的布尔值判断
在开头设某变量的布尔值为True，input后开启判断变量的布尔值是否改变。
当得到肯定回复时，while True，继续运行；当得到否定回复时，while False，停止循环，退出游戏。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# 方案1
while True:
    a1 = input('要继续游戏吗，请输入n退出，输入其他继续：')
    if a1 == 'n':
        break


# 方案2
again = True
while again:
    a2 = input('要继续游戏吗，请输入y继续，输入其他退出：')
    if a2 == 'y':
        again = True
    else:
        again = False


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


#for循环
import time
import random



for i in range(1,4):
    player_victory = 0
    enemy_victory = 0
    time.sleep(1.5)
    print('  \n——————现在是第 %s 局——————' % i)
    player_life = random.randint(100,150)
    player_attack = random.randint(30,50)
    enemy_life = random.randint(100,150)
    enemy_attack = random.randint(30,50)

    print('【玩家】\n血量：%s\n攻击：%s' % (player_life,player_attack))
    print('------------------------')
    time.sleep(1)
    print('【敌人】\n血量：%s\n攻击：%s' % (enemy_life,enemy_attack))
    print('-----------------------')
    time.sleep(1)

    while player_life > 0 and enemy_life > 0:
        player_life = player_life - enemy_attack 
        enemy_life = enemy_life - player_attack
        print('你发起了攻击，【玩家】剩余血量%s' % player_life)
        print('敌人向你发起了攻击，【敌人】的血量剩余%s' % enemy_life)
        print('-----------------------')
        time.sleep(1.2)

    if player_life > 0 and enemy_life <= 0:
        player_victory += 1
        print('敌人死翘翘了，你赢了！')
    elif player_life <= 0 and enemy_life > 0:
        enemy_victory += 1
        print('悲催，敌人把你干掉了！')
    else:
        print('哎呀，你和敌人同归于尽了！')

if player_victory > enemy_victory :
    time.sleep(1)
    print('\n【最终结果：你赢了！】')
elif enemy_victory > player_victory:
    print('\n【最终结果：你输了！】')
else: 
    print('\n【最终结果：平局！】')
 


#while 循环  
import time
import random




while True:
    player_victory = 0
    enemy_victory = 0
    for i in range(1,4):
        time.sleep(1.5)
        print('  \n——————现在是第 %s 局——————' % i)
        player_life = random.randint(100,150)
        player_attack = random.randint(30,50)
        enemy_life = random.randint(100,150)
        enemy_attack = random.randint(30,50)

        print('【玩家】\n血量：%s\n攻击：%s' % (player_life,player_attack))
        print('------------------------')
        time.sleep(1)
        print('【敌人】\n血量：%s\n攻击：%s' % (enemy_life,enemy_attack))
        print('-----------------------')
        time.sleep(1)

        while player_life > 0 and enemy_life > 0:
            player_life = player_life - enemy_attack 
            enemy_life = enemy_life - player_attack
            print('你发起了攻击，【玩家】剩余血量%s' % player_life)
            print('敌人向你发起了攻击，【敌人】的血量剩余%s' % enemy_life)
            print('-----------------------')
            time.sleep(1.2)

        if player_life > 0 and enemy_life <= 0:
            player_victory += 1
            print('敌人死翘翘了，你赢了！')
        elif player_life <= 0 and enemy_life > 0:
            enemy_victory += 1
            print('悲催，敌人把你干掉了！')
        else:
            print('哎呀，你和敌人同归于尽了！')

    if player_victory > enemy_victory :
        time.sleep(1)
        print('\n【最终结果：你赢了！】')
    elif enemy_victory > player_victory:
        print('\n【最终结果：你输了！】')
    else: 
        print('\n【最终结果：平局！】')

    a1 = input('要继续游戏吗，请输入n退出，输入其他继续：')
    if a1 == 'n':
        break



________________________________________________________________________________________________



在这个练习，我们会学会一种新的“格式化字符串”的方法：format()函数。
 
学习format()函数
format()函数是从 Python2.6 起新增的一种格式化字符串的函数，功能比课堂上提到的方式更强大。
format()函数用来占位的是大括号{}，不用区分类型码（%+类型码）。
具体的语法是：'str.format()'，而不是课堂上提到的'str % ()'。
而且，它对后面数据的引用更灵活，不限次数，也可指定对应关系。
看完左侧的代码、结果和注释，你就懂上面几句话的意思了。
 
运用format()函数
将代码中字符串格式化的代码改成format()函数的方法，改完后运行一下，检验是否正确。

 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


import time
import random


player_victory = 0
enemy_victory = 0


while True:
    for i in range(1,4):
        time.sleep(1.5)
        print('  \n——————现在是第 {} 局——————'.format(i))
        player_life = random.randint(100,150)
        player_attack = random.randint(30,50)
        enemy_life = random.randint(100,150)
        enemy_attack = random.randint(30,50)


        print('【玩家】\n血量：{}\n攻击：{}'.format(player_life,player_attack))
        print('------------------------')
        time.sleep(1)
        print('【敌人】\n血量：{}\n攻击：{}'.format(enemy_life,enemy_attack))
        print('-----------------------')
        time.sleep(1)


        while player_life > 0 and enemy_life > 0:
            player_life = player_life - enemy_attack 
            enemy_life = enemy_life - player_attack
            print('敌人发起了攻击，【玩家】剩余血量{}'.format(player_life))
            print('你发起了攻击，【敌人】的血量剩余{}'.format(enemy_life))
            print('-----------------------')
            time.sleep(1.2)


        if player_life > 0 and enemy_life <= 0:
            player_victory += 1
            print('敌人死翘翘了，你赢了！')
        elif player_life <= 0 and enemy_life > 0:
            enemy_victory += 1
            print('悲催，敌人把你干掉了！')
        else:
            print('哎呀，你和敌人同归于尽了！')


    if player_victory > enemy_victory :
        time.sleep(1)
        print('\n【最终结果：你赢了！】')
    elif enemy_victory > player_victory:
        print('\n【最终结果：你输了！】')
    else: 
        print('\n【最终结果：平局！】')


    a1 = input('要继续游戏吗，请输入n退出，输入其他继续：')
    if a1 == 'n':
        break



________________________________________________________________________________________________




1. 合并列表-1
分析问题，明确结果
我们的问题是：将两个列表合并起来，并按照从低到高的顺序排序，要得到问题的结果，我们还需要借助打印函数看看我们合并的是否正确。
 
思考要用到的知识&思考切入点
增加列表的内容与合并列表的含义相同，所以我们可以使用append作为解题的切入点，请你试试！
提示：假设要用已学过的知识来完成这道作业，需要用到列表的新增函数和循环。
 

list1 =  [91, 95, 97, 99]  
list2 =  [92, 93, 96, 98]
for i in list2:
    list1.append(i)
print(list1)




2.合并列表-2
上网搜索新知识&找到新的切入点
好了。你已经完成了第一个需求：合并列表。不过，有没有发现，这个代码还是比较冗余的。有没有更简单的方法呢？请你自己上网搜索一下
 `python 合并两个列表`，看看是否有更简单的方法（提示：以字母e开头），学会后再回来继续做作业吧。
请你根据新学到的知识，简化代码。
注（如果你直接将 list2 合并到 list1 上，那就无法做到只看A组的成绩，所以，最好再建一个列表来合并两组的成绩）


list1 =  [91, 95, 97, 99]  
list2 =  [92, 93, 96, 98]
# 把 A 组成绩赋值给一个新列表，用来存合并的成绩——这个细节要注意！
list3 =list1
list3.extend(list2)
print(list3)




3.列表排序
主动搜索，掌握新知
老师鼓励你自己去探寻解决问题的方法，上网搜索一下列表的排序方法吧，是不是发现了一个以字母s开头的方法？


list3= [91, 95, 97, 99, 92, 93, 96, 98]
list3.sort()
print(list3)


________________________________________________________________________________________________




 练习要求
上一个练习中，我们完成了两组成绩的合并和排序。
不过，老师有了新的需求：想知道两组的平均分，以及把低于平均分的成绩也打印出来。
所以，在这个练习中，我们会帮老师计算出两组的平均分，并挑出那些在平均分之下的成绩。


解题三连击：
1.目前我们想要的结果是：求平均值和判断比较；
2.我们可以用到的知识有：循环叠加成绩，然后除以总人数，即可求平均值。判断比较用小于号和空列表即可；
3.我们的切入点：由于学生的成绩已经被我们集中到一个列表里，所以可以用for循环遍历这个列表来取出小于平均值的成绩。
经过三连击，相信你已经可以帮老师自动化地达成目标了。
 

scores1 =  [91, 95, 97, 99, 92, 93, 96, 98]  
sum = 0
scores2 = []

for score in scores1:
    sum = sum + score
    average = sum/len(scores1)  
print('平均成绩是：{}'.format(average))


for score in scores1:
    if score < average:
        scores2.append(score)
        continue
print(' 低于平均成绩的有：{}'.format(scores2))




第二种 解题三连击：
1.目前我们想要的结果是：求平均值和判断比较；
2.我们可以去找的新知识有：Python 求平均值；
3.我们的切入点：请你通过搜索，找到更简单的求平均值的方法，来改造代码。
 
【提示】
这个方法的单词首字母是“n”，性质是“拓展程序库”。在改造代码前，可以先读懂网上的案例。



import numpy as np


scores1 =  [91, 95, 97, 99, 92, 93, 96, 98]  
scores2 = []


average = np.mean(scores1)  # 一行解决。
print('平均成绩是：{}'.format(average))


for score in scores1:
    if score < average:
        scores2.append(score)
        continue
print(' 低于平均成绩的有：{}'.format(scores2))




________________________________________________________________________________________________




我们已经有一个hellokitty抽奖器，现在，请你把这个程序封装成一个新的函数。



import random
import time

# 用random函数在列表中随机抽奖，列表中只有3位候选者。
luckylist = ['海绵宝宝','派大星','章鱼哥']
# random模块中有个随机选取一个元素的方法：random.choice()。
a = random.choice(luckylist)  # 从3个人中随机选取1个人。
print('开奖倒计时',3)
time.sleep(1)  # 调用time模块，控制打印内容出现的时间
print('开奖倒计时',2)
time.sleep(1)
print('开奖倒计时',1)
time.sleep(1)
# 使用三引号打印hellokitty的头像
image = '''
 /\_)o<
|      \\
| O . O|
 \_____/
'''
print(image)  # ……
print('恭喜'+a+'中奖！')  # 使用print函数打印幸运者名单
import random
import time


运行代码，熟悉了解抽奖器抽奖的原理，请仔细查看注释讲解。
 
分析代码结构，完成函数封装

# 提示：将以下部分封装进函数
luckylist = ['海绵宝宝','派大星','章鱼哥']
a = random.choice(luckylist) 
print('开奖倒计时',3)
time.sleep(1)
print('开奖倒计时',2)
time.sleep(1)
print('开奖倒计时',1)
time.sleep(1)
image = '''
/\_)o<
| \\
| O . O|
\_____/
'''
print(image)
print('恭喜'+a+'中奖！')
# 查看注释，运行代码。
import random
import time

 
抽奖程序分为两部分：
我们需要将第二部分用函数封装起来，并调用函数。提示：3个参与者即函数有3个参数。


import random
import time

# 将抽奖程序封装成函数
def choujiang(q,w,e):  # 定义一个抽奖函数，带有3个参数，也就是3位候选人
    luckylist = [q,w,e]  # 定义一个中奖名单的列表
    a = random.choice(luckylist)  # 在中奖名单里面随机选择
    print('开奖倒计时',3)
    time.sleep(1)
    print('开奖倒计时',2)
    time.sleep(1)
    print('开奖倒计时',1)
    time.sleep(1)
    image = '''
    /\_)o<
    |      \\
    | O . O|
    \_____/
    '''
    print(image)
    print('恭喜'+a+'中奖！')
choujiang('虚竹','萧峰','段誉')  # 调用函数





________________________________________________________________________________________________




练习-生成一副扑克牌


练习要求：
我们将通过这个练习，简单地复习一下return的用法。
另外，这个练习也要求你能够快速地学习新知识并将其运用出来。
新知识有3个：一种新的列表生成方式、extend 的新用法和列表生成式。
 
 三个新知识
请仔细查看右侧的代码和注释。重要的几行代码：


num2 = list(range(1,6))

num2.extend('ABCDE') 

list2 = [m+n for m in ['天字', '地字'] for n in '一二']

list3 = [n*n for n in range(1,11) if n % 3 == 0]




请根据学到的新知识，补全函数cards()。
每张扑克牌的展现形式是一个元组：(花色，大小)。


def cards():
    color = ['红心', '方块', '梅花','黑桃']
    num = list(range(2, 11))
    num.extend('JQKA')
    return [(x, y) for x in color for y in num ]


print(cards())



________________________________________________________________________________________________

通过这个练习，掌握函数定义和调用的基本用法

练习要求：
眼看要过年了，深夜食堂经营的不错，你打算给员工发奖金犒劳一下。请你定义函数，当输入员工姓名和工作时长两个参数，即可打印出该员工获得多少年终奖。



________________________________________________________________________________________________



和电脑玩一个剪刀石头布的游戏：电脑随机出拳，我们可选择出什么。


1.双方出拳
首先，我们要让双方选择出拳，才能判断胜负。
我们可以设置变量computer_choice代表电脑的出拳选择，设置变量user_choice代表你的出拳选择。
电脑的出拳，我们可以使用random.choice()来随机选择；我们的出拳，可以手动输入我们出拳的类型。
另外，判断下输入：当输入的内容不是石头剪刀布时，电脑会提醒'输入有误，请重新出拳'，并重新出拳。



import random
# 出拳

punches = ['石头','剪刀','布']
computer_choice = random.choice(punches)
user_choice = ''
user_choice = input('请出拳：（石头、剪刀、布）')  # 请用户输入选择
while user_choice not in punches:  # 当用户输入错误，提示错误，重新输入
    print('输入有误，请重新出拳')
    user_choice = input()


2.双方亮拳
你和电脑已经对自己要出的拳进行了选择，接下来，我们需要知道双方的出拳类型。
请使用print()函数补充亮拳的结果。


import random

# 出拳
punches = ['石头','剪刀','布']
computer_choice = random.choice(punches)
user_choice = ''
user_choice = input('请出拳：（石头、剪刀、布）')  # 请用户输入选择
while user_choice not in punches:  # 当用户输入错误，提示错误，重新输入
    print('输入有误，请重新出拳')
    user_choice = input()

# 亮拳
print('————战斗过程————')
print('电脑出了：%s' %(computer_choice))
print('你出了：%s' %(user_choice))



3.判断胜负
在前面两步，电脑和你已经选择完出拳的类型并亮拳后，只差最后一步：根据结果判断胜负。
胜负分为三种情况：
两方出拳一致：平局；
你出石头，电脑出剪刀；你出剪刀，电脑出布；你出布，电脑出石头：你获胜；
其他情况：你输了。
根据上面的逻辑将代码补充完整，判断胜负，试试能否运行。


import random

# 出拳
punches = ['石头','剪刀','布']
computer_choice = random.choice(punches)
user_choice = ''
user_choice = input('请出拳：（石头、剪刀、布）')  # 请用户输入选择
while user_choice not in punches:  # 当用户输入错误，提示错误，重新输入
    print('输入有误，请重新出拳')
    user_choice = input()

# 亮拳
print('————战斗过程————')
print('电脑出了：%s' %(computer_choice))
print('你出了：%s' %(user_choice))

# 胜负
print('—————结果—————')



参考答案


punches = ['石头','剪刀','布']
computer_choice = random.choice(punches)
user_choice = ''
user_choice = input('请出拳：（石头、剪刀、布）')  # 请用户输入选择
while user_choice not in punches:  # 当用户输入错误，提示错误，重新输入
    print('输入有误，请重新出拳')
    user_choice = input()

# 亮拳
print('————战斗过程————')
print('电脑出了：%s' %(computer_choice))
print('你出了：%s' %(user_choice))

# 胜负
print('—————结果—————')
if user_choice == computer_choice:  # 使用if进行条件判断
    print('平局！')
elif (user_choice == '石头' and computer_choice == '剪刀') or (user_choice == '剪刀' and computer_choice == '布') or (user_choice == '布' and computer_choice == '石头'):
    print('你赢了！')
else:
    print('你输了！')


________________________________________________________________________________________________



练习要求
上一个练习的代码中，有一个判断语句的代码很长很长：
elif (user_choice == '石头' and computer_choice == '剪刀') or (user_choice == '剪刀' and computer_choice == '布') or (user_choice == '布' and computer_choice == '石头'):
我们会通过一个新的知识，将其简化，体验到“知识得增加，代码得简化”这个客观规律。
 
【讲解】
明确目标很重要（所以重复三遍）。
做到后面的步骤，可再点开左侧的“练习介绍”查看。
 
index()函数
index() 函数用于找出列表中某个元素第一次出现的索引位置。
语法为：list.index(obj)，obj为object（对象）的缩写。
具体可参考右侧的代码和运行结果。
现在，请你根据新学的函数去简化代码吧。


import random

punches = ['石头','剪刀','布']
computer_choice = random.choice(punches)
user_choice = ''
user_choice = input('请出拳：（石头、剪刀、布）')
while user_choice not in punches:
    print('输入有误，请重新出拳')
    user_choice = input()

print('————战斗过程————')
print('电脑出了：%s' % computer_choice)
print('你出了：%s' % user_choice)

print('—————结果—————')
if user_choice == computer_choice:
    print('平局！')
elif user_choice == punches[punches.index(computer_choice)-1]:
    print('你赢了！')
else:
    print('你输了！')





________________________________________________________________________________________________


知识点debug

scores = {'语文':89, '数学':95, '英语':80}
def get_average(scores):
    sum_score = 0
    for subject, score in scores.items():
        sum_score += score
        print('现在的总分是%d'%sum_score)
    ave_score = sum_score/len(scores)
    print('平均分是%d'%ave_score)

get_average(scores)






________________________________________________________________________________________________

思维不清debug


not_bad_word = True
while not_bad_word:
    x = input('请给旺财取个外号：')
    if x == '小狗' or x =='汪汪':  # 只要外号是两个中的一个，就会生气。
        not_bad_word = False
        print('我生气了，不想理你了！')


print('对不起，以后我不会这么叫你了')



________________________________________________________________________________________________



被动掉坑debug


deposit = [100,300,900,2000,5000,0,2000,4500]

for i in range(1, len(deposit)):
    if deposit[i-1] == 0:  # 判断被除数等于0时，特殊处理。
        print('你上次存款为 0 哦！')
    else:
        times = deposit[i]/deposit[i-1]
        print('你的存款涨了%f倍'%times)




________________________________________________________________________________________________



练习-贴心的除法计算器-参考
 
练习目标：
通过这个练习，我们会用代码做出一个贴心的除法计算器：只要输入有误，就会给出相应的报错信息。
 
练习要求：
这个除法计算器需要包含的报错信息有：输入了非数值（即不属于整数和浮点数）、被除数为零以及变量不存在。
为了让代码可以给出相应的报错信息，我们可以运用课堂中谈到的`try...except`语句。
 
【讲解】
明确目标很重要（所以重复三遍）。
做到后面的步骤，可再点开左侧的“练习介绍”查看。
 
回顾和升级
我们以课堂中的一个代码为例，回顾并升级对`try...except`语句的用法。
请你按照右侧代码区的提醒阅读和运行代码，了解带多个except的try结构。
 
【提示】
有兴趣的话，可阅读课堂末的链接，了解`try...except`的更多用法和变形。
请你找到右侧的代码可能会出现的几种报错（可运行尝试），然后用带多个except的try结构来解决这些可能出现的输入错误。
 
第二个报错信息是：ValueError，你找到了吗





print('\n欢迎使用除法计算器！\n')


while True:
    try:
        x = input('请你输入被除数：')
        y = input('请你输入除数：')
        z = float(x)/float(y)
    except ZeroDivisionError:
        print('0是不能做除数的！')
    except ValueError:
        print('除数和被除数都应该是整值或浮点数！')
    else:
        print(x,'/',y,'=',z)
        break


________________________________________________________________________________________________

1.新增业绩的类方法
【参考】


# 创建一个人事系统类
class hrSystem:
    # 创建存储员工名字的变量 name
    name = ''
    # 创建存储员工工资的变量 salary
    salary = 0
    # 创建存储员工绩效的变量 kpi 
    kpi = 0

    # 定义录入员工信息的类方法
    @classmethod
    def record(cls, name, salary, kpi):
        cls.name = name
        cls.salary = salary
        cls.kpi = kpi

    # 定义打印员工信息的类方法
    @classmethod
    def print_record(cls):
        print(cls.name + '的工作信息如下：')
        print('本月工资：' + str(cls.salary))
        print('本年绩效：' + str(cls.kpi))

    # 定义根据 kpi 评奖的类方法
    @classmethod
    def kpi_reward(cls):
        if cls.kpi > 95:
            print('恭喜' + cls.name + '拿到明星员工奖杯！')
        elif cls.kpi <= 95 and cls.kpi >= 80:
            print('恭喜' + cls.name + '拿到优秀员工奖杯！')
        else:
            print('很遗憾' + cls.name + '这次没有评上奖杯，希望来年努力工作，勇创佳绩！')

# 验证结果的代码        
hrSystem.record('bob', 13000, 98)
hrSystem.kpi_reward()
hrSystem.record('candy', 8000, 89)
hrSystem.kpi_reward()
hrSystem.record('jony', 8000, 75)
hrSystem.kpi_reward()




2.新增检测名字的类方法


# 创建一个人事系统类
class hrSystem:
    # 创建存储员工名字的变量 name
    name = ''
    # 创建存储员工工资的变量 salary
    salary = 0
    # 创建存储员工绩效的变量 kpi 
    kpi = 0

    # 定义录入员工信息的类方法
    @classmethod
    def record(cls, name, salary, kpi):
        cls.name = name
        cls.salary = salary
        cls.kpi = kpi

    # 定义打印员工信息的类方法
    @classmethod
    def print_record(cls):
        print(cls.name + '的工作信息如下：')
        print('本月工资：' + str(cls.salary))
        print('本年绩效：' + str(cls.kpi))

    # 定义根据 kpi 评奖的类方法
    @classmethod
    def kpi_reward(cls):
        if cls.kpi > 95:
            print('恭喜' + cls.name + '拿到明星员工奖杯！')
        elif cls.kpi <= 95 and cls.kpi >= 80:
            print('恭喜' + cls.name + '拿到优秀员工奖杯！')
        else:
            print('很遗憾' + cls.name + '这次没有评上奖杯，希望来年努力工作，勇创佳绩！')

    # 检查录入名称是否正确的类方法   
    @classmethod
    def check_name(cls):
        if cls.name not in ['bob', 'candy', 'jony', 'kelly']:
            print('录入错误！' + cls.name + '不是本公司员工！')
        else:
            print('录入正确~')

# 验证结果的代码
hrSystem.record('bob', 13000, 98)
hrSystem.check_name()
hrSystem.record('spy', 3000, 60)
hrSystem.check_name()




3.优化代码
【参考】



# 创建一个人事系统类
class hrSystem:
    # 创建存储员工名字的变量 name
    name = ''
    # 创建存储员工工资的变量 salary
    salary = 0
    # 创建存储员工绩效的变量 kpi 
    kpi = 0

    # 定义录入员工信息的类方法
    @classmethod
    def record(cls, name, salary, kpi):
        cls.name = name
        cls.salary = salary
        cls.kpi = kpi

    # 定义打印员工信息的类方法
    @classmethod
    def print_record(cls):
        if cls.check_name():  # 以 cls.check_name() 的返回值（0或1）作为判断条件。
            print(cls.name + '的工作信息如下：')
            print('本月工资：' + str(cls.salary))
            print('本年绩效：' + str(cls.kpi))

    # 定义根据 kpi 评奖的类方法
    @classmethod
    def kpi_reward(cls):
        if cls.kpi > 95:
            print('恭喜' + cls.name + '拿到明星员工奖杯！')
        elif cls.kpi <= 95 and cls.kpi >= 80:
            print('恭喜' + cls.name + '拿到优秀员工奖杯！')
        else:
            print('很遗憾' + cls.name + '这次没有评上奖杯，希望来年努力工作，勇创佳绩！')
        
    # 检查录入名称是否正确的类方法
    @classmethod
    def check_name(cls):
        if cls.name not in ['bob', 'candy', 'jony', 'kelly']:
            print('录入错误！' + cls.name + '不是本公司员工！')
            return 0  # 设置返回值为0
        else:
            print('录入正确~')
            return 1  # 设置返回值为1

# 验证结果的代码
hrSystem.record('spy', 3000, 60)
hrSystem.print_record()



________________________________________________________________________________________________


练习要求
为类calendar添加两个方法：一个删除完成项，一个添加新增项。
由于日程安排是事情和时间的配对，所以我们用字典来存放：
`{'给父母买礼物':'9:00', '学习':'10:00', '和朋友聚会':'18:30'}`
接下来，需要你新建两个类方法，从而实现字典中的数据增减。
 
【讲解】
 
明确目标很重要（所以重复三遍）。
做到后面的步骤，可再点开左侧的“练习介绍”查看。
 
 新建两种类方法
请你补全右侧的代码，让其成功运行，且结果为：
`{'给父母买礼物':'9:00', '学习':'10:00', '和朋友聚会':'18:30'}`
 
【提示】
这两个类方法的参数个数分别为2和3（删除只要键，新增要键值对）。




class calendar:
    date = '2020-08-08'
    things = {'给父母买礼物':'9:00', '学习':'10:00', '和朋友聚会':'18:30'}


    @classmethod
    def thing_done(cls, thing):
        del cls.things[thing]


    @classmethod
    def add_thing(cls, thing, time):
        cls.things[thing] = time


calendar.thing_done('给父母买礼物')
calendar.add_thing('写日记', '20:00')
print(calendar.things)






________________________________________________________________________________________________


class Chinese:


    def __init__(self,hometown,region):
        self.hometown = hometown
        self.region = region
        print('程序持续更新中……')


    def born(self):
        print('我生在%s。'%(self.hometown))


    def live(self):
        print('我在%s。'%(self.region))
    
    # 新建方法，调用上面的两个方法（注：方法名可自定义）。
    def citys(self):
        self.born()
        self.live()


wufeng = Chinese('广东', '深圳')
wufeng.citys()





________________________________________________________________________________________________


class Robot:
    def __init__(self):
        self.name = input('我现在刚诞生，还没有名字，帮我起一个吧。')
        self.master = input('对了，我要怎么称呼你呢？')
        print('你好%s，我叫%s。很开心，遇见你~'%(self.master,self.name))
    
    def say_wish(self):
        wish = input('告诉一个你的愿望吧：')
        print(self.master+'的愿望是：')
        # 这里也可以用字符串的格式化，不过，用循环语句的话，之后改复述次数会方便些。
        for i in range(3):
            print(wish)


robot1 = Robot()
robot1.say_wish()



________________________________________________________________________________________________


1.问卷答案的储存


# 不用运行，读懂即可。
class Survey():
    # 收集调查问卷的答案
    def __init__(self, question):
        self.question = question
        # 定义收集问卷问题答案的列表
        self.response = []
   
    # 显示调查问卷的题目
    def show_question(self):
        print(self.question)

    # 存储问卷搜集的答案
    def store_response(self, new_response):
        self.response.append(new_response)  
        # 将答案添加到列表self.response（见第7行
 





________________________________________________________________________________________________

2.搜集问题-最喜欢的美食



class Survey():
    # 收集调查问卷的答案
    def __init__(self, question):
        self.question = question
        self.response = []
    
    # 显示调查问卷的题目
    def show_question(self):
        print(self.question)

    # 存储问卷搜集的答案
    def store_response(self, new_response):
        self.response.append(new_response)

# 请实例化Survey()类，并且显示出这次的调查问卷问题。
food_survey = Survey('你最喜欢的美食是什么？')  # 类的实例化，同时为参数question赋值。
food_survey.show_question()  # 调用类方法打印问题

# 存储问卷调查的答案
while True:
    response = input('请回答问卷问题，按 q 键退出：')
    if response == 'q':
        break
    food_survey.store_response(response)  # 再次调用类方法，进行问答的收集。

# 输出测试
for food in food_survey.response:
    print('美食：' + food)




________________________________________________________________________________________________



3.实名问卷：搜集名字和籍贯地


class Survey():
    # 收集调查问卷的答案
    def __init__(self, question):
        self.question = question
        self.response = []
    
    # 显示调查问卷的题目
    def show_question(self):
        print(self.question)

    # 存储问卷搜集的答案
    def store_response(self, new_response):
        self.response.append(new_response)

# 请定义实名调查问卷的新类 RealNameSurvey，继承自 Survey 类
class RealNameSurvey(Survey):
    def __init__(self, question):
        Survey.__init__(self, question)
        self.response = {}  # 由于籍贯地和名字挂钩，所以用构成为“键值对”的字典来存放。
    
    # 存储问卷搜集的答案（覆盖父类的类方法）
    def store_response(self, name, new_response):  # 除了 self，还需要两个参数。
        self.response[name] = new_response  # 键值对的新增

survey = RealNameSurvey('你的籍贯地是哪？')
survey.show_question()
while True:
    response = input('请回答问卷问题，按 q 键退出：')
    if response == 'q':
        break
    name = input('请输入回答者姓名：')
    survey.store_response(name, response)  # 调用类方法，将两次通过 input 的字符串存入字典。

# 输出测试
for name, value in survey.response.items():
    print(name + '：' + value)
    



________________________________________________________________________________________________



练习-那个男人来了-参考
练习目标：
这个练习，会训练你去运用“子类的继承和定制”相关知识。
 
练习要求：
在练习中，需要你通过代码的运行结果和所学知识，补全代码。
在补全代码的过程中，需要对子类的继承和定制有清晰的认知。
 
【讲解】
明确目标很重要（所以重复三遍）。
做到后面的步骤，可再点开左侧的“练习介绍”查看。
 
根据结果，倒推代码
请你补充右侧代码，让其运行结果如下：
大家注意了！
一个叫“吉多”的人来了。
大家注意了！
一个叫“范罗苏姆”的男人来了。
大家注意了！
那个叫“范罗苏姆”的男人留下了他的背影。
 
【提示】
几个提示：
1.每次实例化都会打印“大家注意了！”，所以可以把它放在初始化函数中；
2.父类的实例化有传入参数，子类的不用，说明继承时改造了初始化函数；
3.子类比父类多了一种方法（因父类生成的对象无法调用），可知这个方法是在子类中新增的。





class Person:
    def __init__(self, name):
        self.name = name
        print('大家注意了！')


    def show(self):
        print('一个叫“%s”的人来了。' % self.name)


class Man(Person):
    def __init__(self):
        Person.__init__(self, name='范罗苏姆')

    def show(self):
        print('一个叫“%s”的男人来了。' % self.name)


    def leave(self):  # 子类定制新方法
        print('那个叫“%s”的男人留下了他的背影。' % self.name)


author1 = Person('吉多')
author1.show()
author2 = Man()
author2.show()
author3 = Man()
author3.leave()




________________________________________________________________________________________________


class Teacher:
    face = 'serious'
    job = 'teacher'

class Father:
    face = 'sweet'
    parenthood = 'dad'

class TeacherMore(Teacher, Father):
    pass

class FatherMore(Father, Teacher):
    face = 'gentle'

time3 = TeacherMore()
time4 = FatherMore()
print(time3.face)
print(time4.face)







class Student:
    def __init__(self, name, job=None, time=0.00, time_effective=0.00): 
        self.name = name
        self.job = job
        self.time = time
        self.time_effective = time_effective


    def count_time(self, hour, rate):
        self.time += hour
        self.time_effective += hour * rate


class Programmer(Student):
    def __init__(self, name):
        Student.__init__(self, name, job='programmer', time=0.00, time_effective=0.00)


    def count_time(self, hour, rate=1):
        Student.count_time(self, hour, rate)


student1 = Student('韩梅梅')
student2 = Programmer('李雷')
print(student1.job)
print(student2.job)
student1.count_time(10, 0.8)
student2.count_time(10)
print(student1.time_effective)
print(student2.time_effective)




________________________________________________________________________________________________



1.代码实验


import random

player_list = ['【圣光骑士】','【暗影刺客】','【精灵弩手】']
players = []

for i in range(3):
    player = random.choice(player_list)
    players.append(player)

print(players)

# 判断方式1：比较运算符

# 角色类型都一样
if players[0] == players[1] == players[2]:
    print('我们都一样！——方式1')  # 在打印结果中加上“方式N”，验证不同的判断方式的有效性。

# 角色类型都不一样
if players[0] != players[1] and players[0] != players[2] and players[1] != players[2]:
    print('我们都不一样！——方式1')

# 判断方式2：set()
# 集合（set）是一个无序的不重复元素序列，set()可以去重，然后生成一个集合。

players_set = set(players)

# 角色类型都一样&角色类型都不一样
if len(players_set) == 1:
    print('我们都一样！——方式2')
elif len(players_set) == 3:
    print('我们都不一样！——方式2')

# 其他判断方式

'''
除了上面两种方式外，还有很多方式可以考虑：

例如：类似判断方式2，可以新建一个列表，用 append 添加不重复的角色类型，然后看这个列表的长度是多少（类似判断方式2）。
再如：“角色类型完全不一样”，可先将players和player_list按相同的排序方式排一下，再判断两个排序后的列表是否相同。


总而言之：只要你愿意思考、尝试和搜索，就可以得出各种不同的判断方式。
'''

# 再举一个例子：
if sorted(players) == sorted(player_list):
    print('我们都不一样！——方式3')
else:
    pass




2.加新功能



# 查看新增的代码和注释


import random
import time


# 创建一个类，可实例化成具体的游戏角色
class Role:
    def __init__(self, name):
        self.name = name
        self.life = random.randint(100,150)
        self.attack = random.randint(30,50)


# 创建3个子类，可实例化为3个不同的角色类型


class Knight(Role):
    def __init__(self, name = '【圣光骑士】'):
        Role.__init__(self,name)
        self.life = int(self.life*1.5)
        self.attack = int(self.attack*0.8)


    def fight_buff(self, opponent,str1,str2):
        if opponent.name  == '【暗影刺客】':
            self.attack = int(self.attack * 1.5)
            print('『%s』【圣光骑士】对 『%s』【暗影刺客】说：“让无尽光芒制裁你的堕落！”'%(str1, str2))


class Assassin(Role):
    def __init__(self, name = '【暗影刺客】'):
        Role.__init__(self,name)
        self.life = int(self.life*0.8)
        self.attack = int(self.attack*1.5)


    # 角色类型克制关系
    def fight_buff(self, opponent,str1,str2):
        if opponent.name  == '【精灵弩手】':
            self.attack = int(self.attack * 1.5)
            print('『%s』【暗影刺客】对 『%s』【精灵弩手】说：“主动找死，就别怪我心狠手辣。”'%(str1, str2)) 


class Bowman(Role):
    def __init__(self, name = '【精灵弩手】'):
        Role.__init__(self,name)
        self.life = int(self.life*1.2)
        self.attack = int(self.attack*1.2)


    def fight_buff(self, opponent,str1,str2):
        if opponent.name  == '【圣光骑士】':
            self.attack = int(self.attack * 1.5)
            print('『%s』【精灵弩手】对 『%s』【圣光骑士】说：“骑着倔驴又如何？你都碰不到我衣服。”'%(str1, str2))


# 创建一个类，可生成3V3并展示：可分为：欢迎语→随机生成→展示角色
class Game:
    def __init__(self):
        self.players = []
        self.enemies = []
        self.score = 0
        self.i = 0
        # 依次执行以下函数
        self.game_start()  # 欢迎语
        self.born_role()  # 随机生成6个角色
        self.cooperat_role()  # 角色类型引起的属性加成
        self.show_role()  # 展示角色
        self.order_role()  # 排序并展示
        self.pk_role()  # 让双方 Pk 并展示结果
        self.show_result()  # 展示最终结局


    # 欢迎语
    def game_start(self):
        print('------------ 欢迎来到“炼狱角斗场” ------------')
        print('在昔日的黄昏山脉，奥卢帝国的北境边界上，有传说中的“炼狱角斗场”。')
        print('鲜血与战斗是角斗士的归宿，金钱与荣耀是角斗士的信仰！')
        print('今日，只要你【你的队伍】能取得胜利，你将获得一笔够花500年的财富。')
        time.sleep(2)
        print('将随机生成【你的队伍】和【敌人队伍】！')
        input('\n狭路相逢勇者胜，请按任意键继续。\n')
    
    # 随机生成6个角色
    def born_role(self):
        for i in range(3):
            self.players.append(random.choice([Knight(),Assassin(),Bowman()]))
            self.enemies.append(random.choice([Knight(),Assassin(),Bowman()]))


    # 判断是否满足角色类型配合的条件
    def cooperat_role(self):
        players_list = [self.players[0].name,self.players[1].name,self.players[2].name]
        enemies_list = [self.enemies[0].name,self.enemies[1].name,self.enemies[2].name]
        players_set = set(players_list)
        enemies_set = set(enemies_list)
        # print(players_list)  # 这几行是验证代码，正式代码里会删掉。感兴趣的话，可取消注释后一起运行。
        # print(players_set)
        # print(enemies_list)
        # print(enemies_set)
        if len(players_set) == 1:
            print('我方触发了“角色类型一致”的条件，每个角色的血量增加25%。')
            for i in range(3):
                self.players[i].life = int(self.players[i].life * 1.25)
        if len(players_set) == 3:
            print('我方触发了“角色类型兼备”的条件，每个角色的攻击增加25%。')
            for i in range(3):
                self.players[i].attack = int(self.players[i].attack * 1.25)
        if len(enemies_set) == 1:
            print('敌方触发了“角色类型一致”的条件，每个角色的血量增加25%。')
            for i in range(3):
                self.enemies[i].life = int(self.enemies[i].life * 1.25)
        if len(enemies_set) == 3:
            print('敌方触发了“角色类型兼备”的条件，每个角色的攻击增加25%。')
            for i in range(3):
                self.enemies[i].attack = int(self.enemies[i].attack * 1.25)
        input('请按任意键，查看【你的队伍】和【敌人队伍】的角色信息：')  # 缓一缓，再展示。



    # 展示角色
    def show_role(self):
        print('----------------- 角色信息 -----------------')
        print('你的队伍：')
        for i in range(3):
            print( '『我方』%s 血量：%s  攻击：%s'%
            (self.players[i].name,self.players[i].life,self.players[i].attack))
        print('--------------------------------------------')


        print('敌人队伍：')
        for i in range(3):
            print('『敌方』%s 血量：%s  攻击：%s'%
            (self.enemies[i].name,self.enemies[i].life,self.enemies[i].attack))
        print('--------------------------------------------')
        input('请按回车键继续。\n')




    # 排序并展示
    def order_role(self):
        order_dict = {}
        i=0
        while i < 3:
            order = int(input('你想将 %s 排在第几个上场？（输入数字1-3）'%(self.players[i].name)))
            if order in [1,2,3]:
                if order in order_dict:
                    print('你输入了重复的数字，请重新输入：')
                else:
                    order_dict[order] = self.players[i]
                    i += 1
            else:
                print('输入有误，请输入1或2或3：')
        self.players = []
        for i in range(1,4):
            self.players.append(order_dict[i]) 
        print('\n你的队伍出场顺序是：%s、%s、%s'
        %(self.players[0].name,self.players[1].name,self.players[2].name))
        print('敌人队伍出场顺序是：%s、%s、%s'
        %(self.enemies[0].name,self.enemies[1].name,self.enemies[2].name))





    # 让双方 Pk 并展示结果
    def pk_role(self):
        for i in range(3):
            print('\n----------------- 【第%s轮】 -----------------' % (i+1))
            # 每一局开战前加buff
            self.players[i].fight_buff(self.enemies[i],'我方','敌方')
            self.enemies[i].fight_buff(self.players[i],'敌方','我方')
            input('\n战斗双方准备完毕，请按回车键继续。')
            print('--------------------------------------------')
    
            while self.players[i].life >0 and self.enemies[i].life>0:
                self.enemies[i].life -= self.players[i].attack
                self.players[i].life -= self.enemies[i].attack
                print('我方%s 发起了攻击，敌方%s 剩余血量 %s'%
                (self.players[i].name,self.enemies[i].name,self.enemies[i].life))
                print('敌方%s 发起了攻击，我方%s 剩余血量 %s'%
                (self.enemies[i].name,self.players[i].name,self.players[i].life))
                print('--------------------------------------------')
                time.sleep(1)
            if self.players[i].life <= 0 and self.enemies[i].life> 0:
                print('\n很遗憾，我方%s 挂掉了！'% (self.players[i].name))
                self.score -= 1
            elif self.players[i].life >0 and self.enemies[i].life<= 0: 
                print('\n恭喜，我方%s 活下来了。'% (self.players[i].name))
                self.score += 1
            else:
                print('\n我的天，他们俩都死了啊！')




    # 展示最终结局
    def show_result(self):
        input('\n请按回车查看最终结果。\n')
        if self.score >0:
            print('【最终结果】\n你赢了，最终的财宝都归你了！')
        elif self.score == 0:
            print('【最终结果】\n你没有胜利，但也没有失败，在夜色中灰溜溜离开了奥卢帝国。')
        else:
            print('【最终结果】\n你输了。炼狱角斗场又多了几具枯骨。')


game = Game()





________________________________________________________________________________________________


练习目标
通过这个练习，优化项目3中排序部分的代码。
 
练习要求
项目3中的排序，3次输入必须包含1、2、3，否则就会报错（下面可以体验）。
为了避免由于输错而产生的报错，我们可以在原有代码的基础上做一些优化，让程序自动提示，并且能够多次输入，直到成功排序为止。
 
【讲解】
 
明确目标很重要（所以重复三遍）。
做到后面的步骤，可再点开左侧的“练习介绍”查看。
 
发现问题
请你运行代码3次，在排序时分别输入：
第一次输入：1→2→3
第二次输入：1→2→2
第三次输入：4→5→6
后面两种输入会报错，你可以想一想为什么会报错以及如何避免这个错误。
 
解决方案
对于解决方案，你有了大致的思路了吗？
想一想以下的场景，你应该会有所启发：
你在注册某APP账号时，假设密码不符合要求，会跳出一个提示说：密码只能是……
当你两次输入的密码不一致时，又会跳出一个提示说：你输入的密码不一致。
同理，我们可以优化一下排序的代码：
当输入的不是123中的某个数字，就跳出提示；当输入的是重复的数字，也跳出提示。
这样，问题得解决，代码得优化。
 
【提示】
1.要保证每个数字都输入了，可用 while 循环判断：每输入一个123中不重复的数字，就记一次有效，需要有效3次；
2.要验证某个元素是否在列表里，可用'if a in list1:'。
 



import random


player_list =  ['【狂血战士】','【森林箭手】','【光明骑士】','【独行剑客】','【格斗大师】','【枪弹专家】']
players = random.sample(player_list,3)  
order_dict = {}


i=0
while i < 3:
    order = int(input('你想将 %s 排在第几个上场？（输入数字1-3）'%(players[i])))
    if order in [1,2,3]:
        if order in order_dict:
            print('你输入了重复的数字，请重新输入：')
        else:
            order_dict[order] = players[i]
            i += 1
    else:
        print('输入有误，请输入1或2或3：')  # 报错2


players = []
for i in range(1,4):
    players.append(order_dict[i]) 
print('\n我方角色的出场顺序是：%s %s %s\n' % (players[0],players[1],players[2]))







________________________________________________________________________________________________



class Book:
 
    def __init__(self, name, author, comment, state = 0):
        self.name = name
        self.author = author
        self.comment = comment
        self.state = state
 
# 创建一个Book类的子类 FictonBook


class FictonBook(Book):
    def __init__(self, name, author, comment, state = 0, type = '虚构类'):
        Book.__init__(self, name, author, comment, state = 0)
        self.type = type


    def __str__(self):
        status = '未借出'
        if self.state == 1:
            status = '已借出'
        return '类型：%s 名称：《%s》 作者：%s 推荐语：%s\n状态：%s ' % (self.type, self.name, self.author, self.comment, status)




book = FictonBook('囚鸟','冯内古特','我们都是受困于时代的囚鸟')
print(book)


________________________________________________________________________________________________



class Book:
 
    def __init__(self, name, author, comment, state = 0):
        self.name = name
        self.author = author
        self.comment = comment
        self.state = state
 
    def __str__(self):
        status = '未借出'
        if self.state == 1:
            status = '已借出'
        return '名称：《%s》 作者：%s 推荐语：%s\n状态：%s ' % (self.name, self.author, self.comment, status)
 
class BookManager:


    authors = []
    def __init__(self):
        book1 = Book('撒哈拉的故事','三毛','我每想你一次，天上便落下一粒沙，从此便有了撒哈拉。')
        book2 = Book('梦里花落知多少','三毛','人人都曾拥有荷西，虽然他终会离去。')
        book3 = Book('月亮与六便士','毛姆','满地都是六便士，他却抬头看见了月亮。')
        self.books = [book1,book2,book3]
        self.authors.append(book1.author)
        self.authors.append(book2.author)
        self.authors.append(book3.author)
 
    def menu(self):
        while True:
            print('1.查询书籍')
            choice = int(input('请输入数字选择对应的功能：'))
            if choice == 1:
                self.show_author_book()
            else:
                print('感谢使用！')
                break
 
    def show_author_book(self):
        author = input('请输入想查询作家的名称：')
        if author in self.authors:
            print(author + '的作品有：')
            for book in self.books:
                if book.author == author:
                    print(book)
        else:
            print('很可惜，我们暂时没有收录这位作者的作品')


manager = BookManager()
manager.menu() 







________________________________________________________________________________________________


练习-数据转移中的变化-参考


1.编码和解码


# 1.分别使用gbk和utf-8编码自己的名字，并将其打印出来。
print('吴枫'.encode('gbk'))
print('吴枫'.encode('utf-8'))

# 2.复制上一步得到的结果，进行解码，打印出你的名字（两次）。
print(b'\xe5\x90\xb4\xe6\x9e\xab'.decode('utf-8'))

# 3.使用gbk解码b'\xb7\xe7\xb1\xe4\xbf\xc6\xbc\xbc\xd3\xd0\xd2\xe2\xcb\xbc'，并打印出来。

print(b'\xb7\xe7\xb1\xe4\xbf\xc6\xbc\xbc\xd3\xd0\xd2\xe2\xcb\xbc'.decode('gbk'))



2.通过文件读写，复制图片


# 先打开图片
with open('photo1.png','rb') as file:  # 以“rb”模式打开图片
    data = file.read()
    with open('photo3.png','wb') as newfile:  # 以“wb”模式写入
        newfile.write(data)




2.在读写之间处理数据-2


file1 = open('scores.txt','r',encoding='utf-8') 
file_lines = file1.readlines() 
file1.close()

final_scores = []

for i in file_lines:
    data =i.split()
    sum = 0  # 先把总成绩设为0
    for score in data[1:]:  # 遍历列表中第1个数据和之后的数据
        sum = sum + int(score)  # 然后依次加起来，但分数是字符串，所以要转换    
    result = data[0]+str(sum)+'\n'  # 结果就是学生姓名和总分
    print(result)
    final_scores.append(result)

print(final_scores)


sum1 = open('winner.txt','w',encoding='utf-8') 
sum1.writelines(final_scores)
sum1.close()
 

2.在读写之间处理数据-2



file1 = open('winner.txt','r',encoding='utf-8') 
file_lines = file1.readlines() 
file1.close()

dict_scores = {}
list_scores = []
final_scores = []

# print(file_lines) 
# print(len('\n'))

# 打印结果为：['罗恩102\n', '哈利383\n', '赫敏570\n', '马尔福275\n']
# 经过测试，发现'\n'的长度是1。所以，名字是“第0位-倒数第5位”，分数是“倒数第4位-倒数第二位”。
# 再根据“左取右不取”，可知：name-[:-4],score-[-4:-1]

for i in file_lines:  # i是字符串。
    print(i)
    name = i[:-4]  # 取出名字（注：字符串和列表一样，是通过偏移量来获取内部数据。）
    score = int(i[-4:-1])  # 取出成绩
    print(name)
    print(score)
    dict_scores[score] = name  # 将名字和成绩对应存为字典的键值对(注意：这里的成绩是键)
    list_scores.append(score)

# print(list_scores)
list_scores.sort(reverse=True)  # reverse，逆行，所以这时列表降序排列，分数从高到低。
# print(list_scores)

for i in list_scores:
    result = dict_scores[i] + str(i) + '\n'
    # print(result)
    final_scores.append(result)

print(final_scores)  # 最终结果

winner_new = open('winner_new.txt','w',encoding='utf-8') 
winner_new.writelines(final_scores)
winner_new.close()




________________________________________________________________________________________________


练习目标
这个练习，会让你学会一种方法，可以直接修改原文件中的数据。
 

练习要求
语文老师将一些古诗存在txt文档里，一句一行。
最近，他计划抽一些古诗，自己设置一些空来让学生默写。
请你用代码帮老师完成这项工作（只要处理了一个文档，加上循环就能处理无数个文档了）。
 
【讲解】
明确目标很重要（所以重复三遍）。
做到后面的步骤，可再点开左侧的“练习介绍”查看。
我们以李商隐的《锦瑟》为例，这是原文档里的内容：
 
锦瑟
[唐] 李商隐
 
锦瑟无端五十弦，
一弦一柱思华年。
庄生晓梦迷蝴蝶，
望帝春心托杜鹃。
沧海月明珠有泪，
蓝田日暖玉生烟。
此情可待成追忆，
只是当时已惘然。
 
老师在这首诗想考学生“一弦一柱思华年。”和“只是当时已惘然。”，即他想得到的是：
 
锦瑟
[唐] 李商隐
 
锦瑟无端五十弦，
____________。
庄生晓梦迷蝴蝶，
望帝春心托杜鹃。
沧海月明珠有泪，
蓝田日暖玉生烟。
此情可待成追忆，
____________。
 
 【提示】
为了让代码逻辑简洁且便于更新，可以将需要默写的诗句都放到一个表格里。
另外，当遇到默写诗句时，可以用英文的下划线去替代（____________）。







list_test = ['一弦一柱思华年。\n','只是当时已惘然。\n']
with open ('poem2.txt','r') as f:
    lines = f.readlines()
print(lines)
with open('poem2.txt','w') as new:
    for line in lines:
        if line in list_test:
            new.write('____________。\n')
        else:
            new.write(line)




________________________________________________________________________________________________



练习-时间记录器-参考



import time

input("欢迎使用“时间管理器”！请按回车继续。")

while True:
    task_name = input('请输入任务名：')
    task_time = int(input('你觉得自己至少可以专注这个任务多少分钟？输入 N 分钟'))
    input('此次任务信息：\n我要完成的任务：%s\n我至少要专注：%d分钟\n按回车开始计时：'%(task_name,task_time))
    start = time.time()  # 开始计时
    start_time = time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))  # 格式化日期
    
    # for t in range(task_time*60,0,-1):  # 实际代码：分钟转成秒要乘60，用-1来倒计时。
    for t in range(task_time,0,-1):
        info = '请专注任务，还要保持专注 ' + str(t) + ' 秒哦！'
        print(info,end="")
        print("\b"*(len(info)*2),end="",flush=True)
        time.sleep(1)
    print('你已经专注了 %d 分钟，很棒~再加把劲，完成任务！'%task_time)  # 倒计时后，才继续运行之后的代码。


    # 询问任务是否完成
    task_status = input('请在任务完成后按输入y:')
    if task_status == 'y':
        end = time.time()  # 一定用户按了 y，就记下结束时间。
        end_time = time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))  # 日期格式化
        actual_time = int((end -start)/60)  # 始末时间相减，从秒换算到分，除以60。
        start_end = start_time + '——' + end_time + '\n'
        with open('timelog3.txt','a', encoding = 'utf-8') as f:
            f.write(task_name + ' 的预计时长为：' + str(task_time) + '分钟\n')
            f.write(task_name + ' 的实际时长为：' + str(actual_time) + '分钟,具体时间为：' + start_end)
        again = input('建立一个新任务请按 y, 退出时间日志记录器请按 q：')
        if again == 'q':            
            break
    else:
        print('抱歉，你的输入有误。请重启时间记录器。')

print('愿被你善待的时光，予你美好的回赠。')






________________________________________________________________________________________________


练习-再出古诗默写题-参考

 
练习目标
通过这个练习，我们会用模块去实现上一关卡的选做题“古诗默写”。
 
练习要求
这个练习，我们会接触一个新的Python内置模块：os（文件/目录方法）。
这个模块中的许多方法，配合文件读写以及数据处理，可以让一些工作得以自动化。
当然，在一个练习里，我们不会奢求那么多，先体验一下os模块里的3个方法即可。
 
【讲解】
明确目标很重要（所以重复三遍）。
做到后面的步骤，可再点开左侧的“练习介绍”查看。
 
我们先回顾一下不用模块是如何出古诗默写题的
 
【提示】
os 模块中的替换方法
可能你会觉得这么操作更麻烦，但假设要你处理大量的文档，模块会让你的代码更清晰更简洁。
细心一些，你可以的！
 


import os

list_test = ['一弦一柱思华年。\n','只是当时已惘然。\n']

with open ('poem2.txt','r') as f:

    lines = f.readlines()

with open('poem2_new.txt','w') as new:

    for line in lines:

        if line in list_test:

            new.write('____________。\n')

        else:

            new.write(line)

os.replace('poem_new.txt', 'poem1.txt')





另外，建议你在本地编辑器试一试下面的这些方法：
 
os.getcwd()  # 返回当前工作目录
os.listdir(path)   # 返回path指定的文件夹包含的文件或文件夹的名字的列表
os.mkdir(path)  # 创建文件夹
os.path.abspath(path)   # 返回绝对路径
os.path.basename(path)   # 返回文件名
os.path.isfile(path)   # 判断路径是否为文件
os.path.isdir(path)   # 判断路径是否为目录
 
注： dir为单词directory（目录）的缩写。





________________________________________________________________________________________________


练习-自制动态二维码-参考




# 先导入模块
from MyQR import myqr


myqr.run(
    words='http://weixin.qq.com/r/kzlje9TEE4lsrZAY92yB',
    # 扫描二维码后，显示的内容，或是跳转的链接
    version=5,  # 设置容错率
    level='H',  # 控制纠错水平，范围是L、M、Q、H，从左到右依次升高
    picture='she-3.gif',  # 图片所在目录，可以是动图
    colorized=True,  # 黑白(False)还是彩色(True)
    contrast=1.0,  # 用以调节图片的对比度，1.0 表示原始图片。默认为1.0。
    brightness=1.0,  # 用来调节图片的亮度，用法同上。
    save_name='Python.gif',  # 控制输出文件名，格式可以是 .jpg， .png ，.bmp ，.gif
    )
    save_dir='指定二维码生成的地址，填写路径就行'








________________________________________________________________________________________________


练习-绝对值的多种求法-参考


练习目标：
通过这个练习，你至少可以用3种方法去求某个数的绝对值。
 
练习要求：
请你通过搜索和步骤中的提示，用不同的方法求绝对值。
建议将其封装成函数，如“abs_value1()”。
 
【讲解】
明确目标很重要（所以重复三遍）。
做到后面的步骤，可再点开左侧的“练习介绍”查看。
 
 
挑战3种方法解题 
 
请根据右侧的关键词提示以及网上搜索，用3种不同的方法求绝对值。
 
【提示】
内置函数为 abs()，内置模块为 math。
 
注：绝对值的英文为 absolute value。
 



import math


def abs_value1():
    a = float(input('1.请输入一个数字：'))
    if a >= 0:
        a = a
    else:
        a = -a
    print('绝对值为：%f' % a)


def abs_value2():
    a = float(input('2.请输入一个数字：'))
    a = abs(a)
    print('绝对值为：%f' % a)


def abs_value3():
    a = float(input('3.请输入一个数字：'))
    a = math.fabs(a)
    print('绝对值为：%f' % a)


abs_value1()
abs_value2()
abs_value3()



________________________________________________________________________________________________




练习-拯救选择困难症-参考



# 帮你做选择之我要吃什么
import random


# 将需要用到的表格和变量放在开头
list_food = ['KFC', '蒸菜馆', '楼下快餐店', '桂林米粉', '东北饺子', '金牌猪脚饭', '三及第汤饭']  # 备选菜单，可自定义。
list_choice = []


# 由于两个原因都包含判断过程，所以，为了让代码更简洁，可将其封装成函数。
def choose(list):,
    while True:
        food = random.choice(list)
        judgement = input('去吃【%s】好不好啊？同意的话输入y，不想吃直接回车即可。'%(food))
        if judgement == 'y':
            print('去吃【%s】！就这么愉快地决定啦！'%(food)) 
            break


# 判断环节
reason = int(input('你不知道吃什么的原因是：1.完全不知道吃什么；2.在几家店之间徘徊（请输入1或2）：'))
if reason == 1:
    choose(list_food)
elif reason == 2:
    add = True
    while add:
        choice = input('请输入让你犹豫的店名（注：一家一家输，完成后输入y）：')
        if choice != 'y':  # 这个判断语句，是为了不将 y 也添加到菜单里。
            list_choice.append(choice)
        if choice == 'y':
            add = False
    choose(list_choice)          
else:
    print('抱歉，目前还不支持第三种情况——不过，你可以加代码哦。')




________________________________________________________________________________________________


练习目标
我们会通过今天的作业，用代码模拟一种现实中的场景：滚动的广告牌。
 
练习要求
实际生活中，有些广告牌是单行滚动的字体。
这个练习会通过新旧知识的结合，用Python实现对这种效果的模拟。
 
【讲解】
明确目标很重要（所以重复三遍）。
做到后面的步骤，可再点开左侧的“练习介绍”查看。
 
提出产品需求，形成技术方案
由于是练习，所以是没有让每个人根据自己的生活经验来提需求。
而是直接给定了产品需求：用Python代码模拟单行的滚动广告。
初步形成的技术方案是：print+字符串+循环+time模块（控制滚动速度）。
 
【讲解】
在这个需求下，稍稍分析即可得：
广告显示：打印字符串；
广告滚动：字符串的改变和循环（注：字符串和列表一样，可以用偏移量来提取数据）。另外，循环的速度影响滚动速度，可以用 time.sleep() 来控制。
 
为了让这种模拟和实际的更接近，补充一个模块中的方法。
请你试着运行右侧的代码，然后将其注释掉，再用代码完成对广告牌的模拟，广告词可以自己起。
对了，正常的滚动广告是无限循环的。不过，你可以在代码中设置循环次数，只要保证效果即可。
 
【提示】
关键代码：
`content = content[1:] + content[0]`






import os, time

def main():

    content = ' 风变编程，陪你一起学Python '  # 广告词可自定义。

    while True:

        os.system('clear')

        print(content)

        content = content[1:] + content[0]

        time.sleep(2)

if __name__ == '__main__':  # 类里面学到的检测方法，在函数中其实也可以用。

    main()


————————————————————————————————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————————————————————————————————



#布尔值的三种使用情况
#两个值在互相比较时
weather = input('请回答：你今天开心吗')
if weather == '开心':
    print('我也替你开心。')




#布尔值的运算
#国师的要求，二选一
v1 = input('对方是达官显贵吗？是/否：')
v2 = input('对方是富可敌国吗？是/否：')
if v1 == '是' or v2 == '是':
    print('国师的要求通过了')
else:
    print('国师的要求没通过')




#女王的要求，都满足
v3 = input('对方善良吗？是/否：')
v4 = input('对方好看吗？是/否：')
if v3 == '是' and v4 == '是':
    print('女王的要求通过了')
else:
    print('女王的要求没通过')


————————————————————————————————————————————————————————————————————————————————————————————————————————


n = 0
while n < 7:
    n = n + 1
    if n == 4:
       continue
    print(n)

————————————————————————————————————————————————————————————————————————————————————————————————————————



1. 猜测我的银行卡余额是几位数（假设是5）。
2. 如果猜大了，提示猜大了；如果猜小了，提示猜小了；如果猜对了，提示猜对了。
3. 总共有三次猜测机会，结束程序。



1. 使用while循环设定3次猜测机会
2. while循环内部使用if...elif...else的条件判断
3. 使用input() 函数获取的数据是字符串，需要用int() 函数进行转换，才能跟数字进行大小比较。





time = 3
while time > 0:
    time = time - 1
    guess_number = int(input('猜猜我的银行卡余额有几位数？'))
    if guess_number > 5:
        print('太多了啦…')
    elif guess_number < 5:
        print('这也太少了!')
    else:
        print('你猜对了!')
        break
if time == 0:
    print('机会用完啦~')




————————————————————————————————————————————————————————————————————————————————————————————————————————




a = {'广东':'广州','四川':'成都','江西':'南昌','江苏':'南京'}
#打印字典a的数据类型
#打印出字典a中的键'广东'、键'江苏'所对应的值

b = [1,2,3,4,5]
#打印出列表b的长度
#打印出列表b中的最后一个值
#打印出列表b中的第0个值
#打印列表中第1个元素和之后所有的值

c = [{'嫉妒':'envy'},{'恨':'hatred'},{'爱':'love'}]
#这是一个嵌套了字典的列表
#请你通过所学的知识，把love这个值取出来,并打印在屏幕上

d = {1:['cake','scone','puff'],2:['London','Bristol','Bath'],3:['love','hatred','envy']}
#这是一个嵌套了列表的字典
#请通过所学的列表和字典的知识，把love这个值取出来，并打印在屏幕上。





a={'广东':'广州','四川':'成都','江西':'南昌','江苏':'南京'}
#打印字典a的数据类型
#打印出字典a中的键'广东'、键'江苏'所对应的值
print(type(a))
print(a['广东'])
print(a['江苏'])

b = [1,2,3,4,5]
#打印出列表b的长度
#打印出列表b中的最后一个值
#打印出列表b中的第0个值
#打印列表中第1个元素和之后所有的值
print(len(b))
print(b[-1])
print(b[0])
print(b[1:])


c = [{'嫉妒':'envy'},{'恨':'hatred'},{'爱':'love'}]
#这是一个嵌套了字典的列表
#请你通过所学的知识，把love这个值取出来,并打印在屏幕上
i = c[2]['爱']
print(i)  

d = {1:['cake','scone','puff'],2:['London','Bristol','Bath'],3:['love','hatred','envy']}
#这是一个嵌套了列表的字典
#请通过所学的列表和字典的知识，把love这个值取出来，并打印在屏幕上。
x = d[3][0]
print(x)



————————————————————————————————————————————————————


【题目】 张国荣是我非常喜欢的一位演员，下面这个字典存储了他的电影作品和相关年份的资料。 请你用for...in...遍历这个字典的键名，然后分别打印出××年张国荣出演了××。 
leslie = {1992:'家有喜事',1993:'霸王别姬',1997:'春光乍泄'}
movie = {1992:'家有喜事',1993:'霸王别姬',1997:'春光乍泄'}
for year in movie:
    print(str(year)+'年张国荣出演了'+movie[year])



————————————————————————————————————————————————————————————————————————————————————————————————————————



【题目】
由于个人的生活习惯，我每天需要7.5h的睡眠时间。
这里有一份我本周每日睡眠时间的记录:


    list0 = [7.5,8.0,6.5,7.0,4.5,5.0,6.0]




要求： 
    1. 定义一个空的列表list1,存放睡眠不足7.5h的睡眠时间数据
    2. 并且统计睡眠不足7.5h的天数<br>


【提示】 
    1. 使用for...in...把list0列表中的数据取出来。
    2. 如果数据小于7.5，使用append()函数追加数据到空列表list1中。
    3. 最后使用len()函数把最后列表的长度统计出来。




list0 = [7.5,8.0,6.5,7.0,4.5,5.0,6.0]
list1 = []
for i in list0:
    if i < 7.5:
        list1.append(i)
print(len(list1))




————————————————————————————————————————————————————————————————————————————————————————————————————————




challenge 2：查电影
【题目】 
    使用input() 函数输入演员的名字时，可以输出“××出演了电影××！”，如果没有找到，输出“查无此人！”
【示例1】 
    输入：黄轩
    输出：黄轩出演了电影妖猫传！
【示例2】 
    输入：周星驰
    输出：查无此人！
电影和对应演员的数据如下：（字典里面嵌套了列表。）


#原始数据如下：
v = {
'妖猫传':['黄轩','染谷将太'],
'无问西东':['章子怡','王力宏','祖峰'],
'超时空同居':['雷佳音','佟丽娅']
}




参考答案：
from sys import exit
v = {
'妖猫传':['黄轩','染谷将太'],
'无问西东':['章子怡','王力宏','祖峰'],
'超时空同居':['雷佳音','佟丽娅']
}

t = input('你想查询哪个演员？')
for i in v:
# 遍历字典
    actors = v[i]
    #将遍历的值赋给变量actors
    if t in actors:
        print(t+'出演了电影'+i)
        exit()
print('查无此人')
# 如果程序没有正常结束循环，说明演员不在我们定义的字典内




————————————————————————————————————————————————————————————————————————————————————————————————————————



我们在课堂中写了一个hellokitty抽奖器。
现在，请你把这个程序定义为一个新的函数，并且带有3个参数，参数为参与者的名单，也就是这个游戏，只有3位候选者。



#这是原始数据
import random
import time
luckylist = ['海绵宝宝','派大星','章鱼哥']
a = random.choice(luckylist)
print('开奖倒计时',3)
time.sleep(1)
print('开奖倒计时',2)
time.sleep(1)
print('开奖倒计时',1)
time.sleep(1)
image = '''
 /\_)o<
|      \\
| O . O|
 \_____/
'''
print(image)
print('恭喜'+a+'中奖！')



【提示】
 luckylist = [q,w,e] #定义一个中奖名单的列表
 a = random.choice(luckylist) #在中奖名单里面随机选择


*********************************************


def choujiang(q,w,e):
    import random
    import time
    luckylist = [q,w,e] #定义一个中奖名单的列表
    a = random.choice(luckylist) #在中奖名单里面随机选择

    print('开奖倒计时',3)
    time.sleep(1)
    print('开奖倒计时',2)
    time.sleep(1)
    print('开奖倒计时',1)
    time.sleep(1)

    image = '''
    /\_)o<
    |      \\
    | O . O|
    \_____/
    '''

    print(image)
    print('恭喜'+a+'中奖！')

choujiang('虚竹','萧峰','段誉')



————————————————————————————————————————————————————————————————————————————————————————————————————————



1. 分别使用gbk和utf-8编码自己的名字。
2. 获取自己名字第0个字的整数编码。
3. 使用gbk解码：b'\xb7\xe7\xb1\xe4\xbf\xc6\xbc\xbc\xd3\xd0\xd2\xe2\xcb\xbc'




print('吴枫'.encode('utf-8'))
print('吴枫'.encode('gbk'))
print(ord('吴'))
print(b'\xb7\xe7\xb1\xe4\xbf\xc6\xbc\xbc\xd3\xd0\xd2\xe2\xcb\xbc'.decode('gbk'))





————————————————————————————————————————————————————————————————————————————————————————————————————————



把课堂中哈利波特成绩的代码，修改读写文件的路径，再重写一遍。
点击【目录】按钮，找到scores.txt文件，写入代码运行之后，会自动生成winner.txt文件。



file = open('scores.txt','r',encoding='utf-8') 
# 用只读模式读取scores.txt
file_lines = file.readlines()
# 以一行为一个元素将文档读成一个列表
file.close()

final_scores = []
#新建一个新列表来存放最后的成绩
for i in file_lines:
# 遍历前面读取的file文档构成的列表
    data =i.split()
    # 将遍历的元素以空格进行分离
    sum = 0
    # 定义一个变量作为总分
    for score in data[1:]:
    # data的第0个元素是学生的姓名，从第一个元素开始是分数，所以从第一个元素开始遍历
        sum = sum + int(score)
        # 计算总分
    result = data[0]+str(sum)+'\n'
    # 最后的结果将名字+总分拼接在一起
    final_scores.append(result)
    #将结果放进列表中
winner = open('winner.txt','w',encoding='utf-8')
winner.writelines(final_scores)
winner.close()
#以上是新建一个winner文档将列表逐行录入




————————————————————————————————————————————————————————————————————————————————————————————————————————



复制以下代码到编辑器，给每一行代码都加上注释，然后再运行。



class Yanhuangzisun():
    hair = 'black'
    skin = 'yellow'
    chinese = True
    def xuemaijuexing(self,words):
        print(words)
qinwang = Yanhuangzisun()
print(qinwang.hair)
print(qinwang.skin)
print(qinwang.chinese)
qinwang.xuemaijuexing('岂曰无衣？与子同裳。王于兴师，修我甲兵。与子偕行。')





class Yanhuangzisun():
#定义一个炎黄子孙的类别
    hair = 'black'
    #属性“头发”为黑
    skin = 'yellow'
    #属性“皮肤”为黄
    chinese = True
    #属性“中国人”为真
    def xuemaijuexing(self,words):
    #定义一个“血脉觉醒”的方法，参数有两个。其中self是系统预设关键词，代表的是这个对象本身，调用该方法时可省略这个参数的填写
    #words是说的话
        print(words)
        #输出words
qinwang = Yanhuangzisun()
#定义一个炎黄子孙，秦王
print(qinwang.hair)
#输出炎黄子孙秦王的头发属性
print(qinwang.skin)
#输出炎黄子孙秦王的皮肤属性
print(qinwang.chinese)
#输出炎黄子孙秦王的中国人属性
qinwang.xuemaijuexing('岂曰无衣？与子同裳。王于兴师，修我甲兵。与子偕行。')
#调用血脉觉醒的方法，打印文字



————————————————————————————————————————————————————————————————————————————————————————————————————————



1. 分别使用requests.text和.content下载《三国演义》第一回
[https://static.pandateacher.com/sanguo.md](https://static.pandateacher.com/sanguo.md)

2. 复制教材中下载音乐的代码并执行，听听看是什么歌[](https://static.pandateacher.com/py_1.mp3)

3. 使用.content下载一张图片[](https://gratisography.com/thumbnails/gratisography-318-thumbnail.jpg)






import requests
#引用requests模块
sanguo = requests.get('https://static.pandateacher.com/sanguo.md')
#下载《三国演义》，我们得到了一个对象，它被命名为sanguo
k = open('《三国演义》.txt','wb')
#创建一个名为《三国演义》的txt文档
k.write(sanguo.content)
#写入数据
k.close()
#关闭文档

import requests
response = requests.get('https://static.pandateacher.com/py_1.mp3')
music = open('music.mp3','wb')
#音频内容，需要以二进制wb读写。你在学习文件读写时接触过它。
music.write(response.content)
#不同于.text是获取文本内容，.content是获取二进制内容，不会产生数据丢失或乱码
#歌是《Five Hundred Miles》，是电影《醉乡民谣》的插曲。

import requests
response = requests.get('https://gratisography.com/thumbnails/gratisography-318-thumbnail.jpg')
pic = open('photo.jpg','wb')
#图片内容，需要以二进制wb读写。你在学习文件读写时接触过它。
pic.write(response.content)
#不同于.text是获取文本内容，.content是获取二进制内容，不会产生数据丢失或乱码。




————————————————————————————————————————————————————————————————————————————————————————————————————————


写个百度



1. 利用requests.get和.text，获取百度首页的源代码，把它复制下来。
2. 打开VS Code新建一个html文档（文件后缀.html），把刚才得到的源代码粘贴进来。
3. 在本地电脑打开你刚刚新建的后缀为html的文档，双击之后，会自动弹出对应的百度网页。
4. 结合之前我们学到的关于编码的知识，思考，为什么会变成这个样子。如何改进？




import requests
baidu = requests.get('http://www.baidu.com')
print(baidu.text)



<!DOCTYPE html>
<!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css><title>ç™¾åº¦ä¸€ä¸‹ï¼Œä½ å°±çŸ¥é“</title></head> <body link=#0000cc> <div id=wrapper> <div id=head> <div class=head_wrapper> <div class=s_form> <div class=s_form_wrapper> <div id=lg> <img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129> </div> <form id=form name=f action=//www.baidu.com/s class=fm> <input type=hidden name=bdorz_come value=1> <input type=hidden name=ie value=utf-8> <input type=hidden name=f value=8> <input type=hidden name=rsv_bp value=1> <input type=hidden name=rsv_idx value=1> <input type=hidden name=tn value=baidu><span class="bg s_ipt_wr"><input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus></span><span class="bg s_btn_wr"><input type=submit id=su value=ç™¾åº¦ä¸€ä¸‹ class="bg s_btn"></span> </form> </div> </div> <div id=u1> <a href=http://news.baidu.com name=tj_trnews class=mnav>æ–°é—»</a> <a href=http://www.hao123.com name=tj_trhao123 class=mnav>hao123</a> <a href=http://map.baidu.com name=tj_trmap class=mnav>åœ°å›¾</a> <a href=http://v.baidu.com name=tj_trvideo class=mnav>è§†é¢‘</a> <a href=http://tieba.baidu.com name=tj_trtieba class=mnav>è´´å§</a> <noscript> <a href=http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb>ç™»å½•</a> </noscript> <script>document.write('<a href="http://www.baidu.com/bdorz/login.gif?login&tpl=mn&u='+ encodeURIComponent(window.location.href+ (window.location.search === "" ? "?" : "&")+ "bdorz_come=1")+ '" name="tj_login" class="lb">ç™»å½•</a>');</script> <a href=//www.baidu.com/more/ name=tj_briicon class=bri style="display: block;">æ›´å¤šäº§å“</a> </div> </div> </div> <div id=ftCon> <div id=ftConw> <p id=lh> <a href=http://home.baidu.com>å…³äºŽç™¾åº¦</a> <a href=http://ir.baidu.com>About Baidu</a> </p> <p id=cp>&copy;2017&nbsp;Baidu&nbsp;<a href=http://www.baidu.com/duty/>ä½¿ç”¨ç™¾åº¦å‰å¿…è¯»</a>&nbsp; <a href=http://jianyi.baidu.com/ class=cp-feedback>æ„è§åé¦ˆ</a>&nbsp;äº¬ICPè¯030173å·&nbsp; <img src=//www.baidu.com/img/gs.gif> </p> </div></div> </div> </body> </html>

创建html，打开：




无法显示的原因：百度首页使用了utf-8编码表，requests却是默认使用Unicode编码表




正确代码：
import requests
baidu = requests.get('http://www.baidu.com')
print(baidu.content.decode('utf-8'))
#先使用utf-8解码，在进行打印即可



正常是没有百度LOGO的，因为百度有反爬虫措施，拦截了你的访问，反爬虫会在后面的课程中讲到
优化版本： 
【提示】 可以利用文件读写，将获取的源代码直接放入一个html文件当中


import requests

baidu = requests.get('http://www.baidu.com')
baidu_html = open('baidu.html','w',encoding='utf-8')
baidu_html.write(baidu.content.decode('utf-8'))
baidu_html.close()






————————————————————————————————————————————————————————————————————————————————————————————————————————



尝试修改一个网页的内容（使用print()函数，描述你做了怎样的修改）


1. 在浏览器中按F12进入到检查页面
2. 点击左上角小箭头，再点击网页中需要修改的元素
3. 跳转到源代码后对源代码内容进行修改


print('我修改了新垣结衣的百度百科页面，新增了唯一合法丈夫。')


再找到两个，在控制台里藏招聘广告的网站（使用print()函数提交）

print(['百度','豆瓣','天猫','掘金','爱奇艺','饿了么','京东'])


识别下面网页中的标签，元素，属性（使用print(函数)提交）


<div class="sld vsc">
<span class="cNifBc">
<h3 class="r">
<a class="l" href="http://news.qq.com/mobile/" data-ved="0ahUKEwjH9O36sonbAhWlAMAKHf0rDD0QjBAILjAB" ping="/url?sa=t&amp;source=web&amp;rct=j&amp;url=http://news.qq.com/mobile/&amp;ved=0ahUKEwjH9O36sonbAhWlAMAKHf0rDD0QjBAILjAB">
新闻客户端
</a>
</h3>
</span>
<div class="s">
<div class="st" style="overflow:hidden;width:220px">
实时推送. 重大新闻瞬间推送到您的手机，随时随地掌握天下事&nbsp;...
<br>
</div>
</div>
</div>




print('''
最外层是一个div元素，标签是div，class属性是sld vsc

内含一个span元素，标签是span，class属性是cNifBc
其中，span元素内，包含一个h3元素，标签是h3，class属性是r

h3元素内，包含一个a元素，标签是a，class属性是l,以及包含href属性、data-ved属性、ping属性、url

其中，div元素外，包含又包含两个div元素，标签是div，第一个标签class属性是s，第二个标签class属性是st，style属性是overflow:hidden;width:220px
''')




————————————————————————————————————————————————————


将本关中的案例，换成自己喜欢的歌手。爬取他的20首歌歌名、所属专辑、时长和播放链接。


import requests,json
#引用json，json是一种跨平台的轻量级数据交换语言。这是一个系统预装模块，你不需要手动安装。
idol = input('请输入你喜欢的歌手：')
url = 'https://c.y.qq.com/soso/fcgi-bin/client_search_cp?ct=24&qqmusic_ver=1298&new_json=1&remoteplace=txt.yqq.song&searchid=60997426243444153&t=0&aggr=1&cr=1&catZhida=1&lossless=0&flag_qc=0&p=1&n=20&w='+idol+'&g_tk=5381&loginUin=0&hostUin=0&format=json&inCharset=utf8&outCharset=utf-8&notice=0&platform=yqq.json&needNewCode=0'
#打开我们新抓取到的网址
res = requests.get(url)
#下载该网页，赋值给res
jsonres = json.loads(res.text)
#使用json来解析res.text
music = jsonres['data']['song']['list']
#一层一层地取字典，获取歌单的列表
for x in music:
#music是一个列表，x是它里面的元素
    print('歌名：'+x['name'])
    #以name为键，查找歌曲名。
    print('所属专辑：'+x['album']['name'])
    #查找专辑名
    print('播放时长：'+str(x['interval'])+'秒')
    #查找播放时长
    print('播放链接：https://y.qq.com/n/yqq/song/'+x['file']['media_mid']+'.html\n\n')
    #查找播放链接


————————————————————————————————————————————————————————————————————————————————————————————————————————



改造爬虫，使它能够爬取周杰伦的100首歌（前5页）的歌名、所属专辑、时长和播放链接。




import requests,json
#引用json，json是一种跨平台的轻量级数据交换语言。这是一个系统预装模块，你不需要手动安装。
for x in range(4):
    url = 'https://c.y.qq.com/soso/fcgi-bin/client_search_cp?ct=24&qqmusic_ver=1298&new_json=1&remoteplace=txt.yqq.song&searchid=60997426243444153&t=0&aggr=1&cr=1&catZhida=1&lossless=0&flag_qc=0&p='+str(x+1)+'&n=20&w=%E5%91%A8%E6%9D%B0%E4%BC%A6&g_tk=5381&loginUin=0&hostUin=0&format=json&inCharset=utf8&outCharset=utf-8&notice=0&platform=yqq.json&needNewCode=0'
    #打开我们新抓取到的网址
    res = requests.get(url)
    #下载该网页，赋值给res
    jsonres = json.loads(res.text)
    #使用json来解析res.text
    music = jsonres['data']['song']['list']
    #一层一层地取字典，获取歌单的列表
    for x in music:
    #music是一个列表，x是它里面的元素
        print('歌名：'+x['name'])
        #以name为键，查找歌曲名。
        print('所属专辑：'+x['album']['name'])
        #查找专辑名
        print('播放时长：'+str(x['interval'])+'秒')
        #查找播放时长
        print('播放链接：https://y.qq.com/n/yqq/song/'+x['mid']+'.html\n\n')
        #查找播放链接



————————————————————————————————————————————————————————————————————————————————————————————————————————



现在你已经学会如何利用爬虫来对文本进行分词和联想相关词汇，现在利用这些知识，去把我们第0个关卡演示的案例，复现出来（只要求实现分词和词汇联想，不要求实现对话）。这个过程中，尽量不要查看我提供的源代码。



import requests,json,time
word = input('''你好，我是你的私人助理吴小枫。请输入你的第0个问题，格式如：XX有哪些相关词汇？然后点击回车
>''')
url1 = 'http://ictclas.nlpir.org/nlpir/index/getAllContentNew.do'
data1 = {'type':'all','content':word}
r1 = requests.post(url1,data1)
dividewords = json.loads(r1.text)['dividewords']
dividewords = dividewords.split(' ')
newwords = []
cixing = []
for x in dividewords:
    if x == dividewords[-1]:
        continue
    else:
        singleword = x.split('/')
        newwords.append(singleword[0])
        cixing.append(singleword[1])
newlist = '/'.join(newwords)
dict = {'n':'名词','nr':'人名','nr1':'汉语姓氏','nr2':'汉语名字','nrj':'日语人名','nrf':'音译人名','ns':'地名','nsf':'音译地名','nt':'机构团体名','nz':'其它专名','nl':'名词性惯用语','ng':'名词性语素',
't':'时间词','tg':'时间词性语素','s':'处所词','f':'方位词',
'v':'动词','vd':'副动词','vn':'名动词','vshi':'动词“是”','vyou':'动词“有”','vf':'趋向动词','vx':'形式动词','vi':'不及物动词（内动词）','vl':'动词性惯用语','vg':'动词性语素',
'a':'形容词','ad':'副形词','an':'名形词','ag':'形容词性语素','al':'形容词性惯用语','b':'区别词','':'','bl':'区别词性惯用语','z':'状态词',
'r':'代词','rr':'人称代词','rz':'指示代词','rzt':'时间指示代词','rzs':'处所指示代词','rzv':'谓词性指示代词','ry':'疑问代词','ryt':'时间疑问代词','rys':'处所疑问代词','ryv':'谓词性疑问代词','rg':'代词性语素',
'm':'数词','mq':'数量词','q':'量词','d':'副词','p':'介词','pba':'介词“把”','pbei':'介词“被”','c':'连词','cc':'并列连词',
'u':'助词','uzhe':'着','ule':'了，喽','uguo':'过','ude1':'的','ude2':'地','ude3':'得','usuo':'所','udeng':'等，等等，云云','uyy':'一样，一般，似的，般','udh':'的话','uls':'来讲，来说，而言，说来','uzhi':'之','ulian':'连',
'e':'叹词','y':'语气词','o':'拟声词','h':'前缀','k':'后缀','x':'字符串','xe':'Email字符串','xs':'微博会话分隔符','xm':'表情符合','xu':'网址URL',
'w':'标点符号','wkz':'左括号','wky':'右括号','wyz':'左引号','wj':'句号','ww':'问号','wt':'叹号','wd':'逗号','wf':'分号','wn':'顿号','wm':'冒号','ws':'省略号','wp':'破折号','wb':'百分号千分号','wh':'单位符号'
}
time.sleep(1)
print('\n我先把你的话做了分词：'+newlist+'。')
cixinglist = ''
for y in cixing:
    cixinglist = cixinglist+dict[y]+'/'
time.sleep(2)
print('它们的词性分别是：'+cixinglist+'。')
time.sleep(2)
print('其中，我判断'+newwords[0]+'是一个'+dict[cixing[0]]+'，你问我的是它的相关词汇有哪些对吗？')
url='http://ictclas.nlpir.org/nlpir/index6/getWord2Vec.do'
data={'content': newwords[0]}
r = requests.post(url,data)
other = json.loads(r.text)
time.sleep(1)
print ('\n我想了想和“'+newwords[0]+'”相关的词汇，至少还有：\n')
time.sleep(1)
f=0
for i in other['w2vlist']:
    f = f + 1
    word2 = i.split(',')
    print ('('+str(f)+')'+word2[0]+'，其相关度为'+word2[1])
    time.sleep(1)





————————————————————————————————————————————————————————————————————————————————————————————————————————


复现第0个关卡当中的人工智能案例，包括实现对话。


1. 实现对话，你可以调用图灵机器人来完成：http://www.tuling123.com/
2. 《接入图灵机器人》：https://shimo.im/docs/4Sn6htUzGdMt11jk




import requests,json,time,random
word = input('''你好，我是你的私人助理吴小枫。请输入你的第0个问题，格式如：XX有哪些相关词汇？然后点击回车
>''')
res = word.find('有哪些相关词汇')
while res<=0:
    time.sleep(1)
    word = input('''请按照正确格式输入，如：牛肉有哪些相关词汇？然后点击回车
>''')
    res = word.find('有哪些相关词汇')
else:
    url1 = 'http://ictclas.nlpir.org/nlpir/index/getAllContentNew.do'
    data1 = {'type':'all','content':word}
    r1 = requests.post(url1,data1)
    dividewords = json.loads(r1.text)['dividewords']
    dividewords = dividewords.split(' ')
    newwords=[]
    cixing = []
    for x in dividewords:
        if x == dividewords[-1]:
            continue
        else:
            singleword = x.split('/')
            newwords.append(singleword[0])
            cixing.append(singleword[1])
    newlist = '/'.join(newwords)
    dict = {'n':'名词','nr':'人名','nr1':'汉语姓氏','nr2':'汉语名字','nrj':'日语人名','nrf':'音译人名','ns':'地名','nsf':'音译地名','nt':'机构团体名','nz':'其它专名','nl':'名词性惯用语','ng':'名词性语素',
't':'时间词','tg':'时间词性语素','s':'处所词','f':'方位词',
'v':'动词','vd':'副动词','vn':'名动词','vshi':'动词“是”','vyou':'动词“有”','vf':'趋向动词','vx':'形式动词','vi':'不及物动词（内动词）','vl':'动词性惯用语','vg':'动词性语素',
'a':'形容词','ad':'副形词','an':'名形词','ag':'形容词性语素','al':'形容词性惯用语','b':'区别词','':'','bl':'区别词性惯用语','z':'状态词',
'r':'代词','rr':'人称代词','rz':'指示代词','rzt':'时间指示代词','rzs':'处所指示代词','rzv':'谓词性指示代词','ry':'疑问代词','ryt':'时间疑问代词','rys':'处所疑问代词','ryv':'谓词性疑问代词','rg':'代词性语素',
'm':'数词','mq':'数量词','q':'量词','d':'副词','p':'介词','pba':'介词“把”','pbei':'介词“被”','c':'连词','cc':'并列连词',
'u':'助词','uzhe':'着','ule':'了，喽','uguo':'过','ude1':'的','ude2':'地','ude3':'得','usuo':'所','udeng':'等，等等，云云','uyy':'一样，一般，似的，般','udh':'的话','uls':'来讲，来说，而言，说来','uzhi':'之','ulian':'连',
'e':'叹词','y':'语气词','o':'拟声词','h':'前缀','k':'后缀','x':'字符串','xe':'Email字符串','xs':'微博会话分隔符','xm':'表情符合','xu':'网址URL',
'w':'标点符号','wkz':'左括号','wky':'右括号','wyz':'左引号','wj':'句号','ww':'问号','wt':'叹号','wd':'逗号','wf':'分号','wn':'顿号','wm':'冒号','ws':'省略号','wp':'破折号','wb':'百分号千分号','wh':'单位符号'
}
    time.sleep(1)
    print('\n我先把你的话做了分词：'+newlist+'。')
    cixinglist = ''
    for y in cixing:
        cixinglist = cixinglist+dict[y]+'/'
    time.sleep(2)
    print('它们的词性分别是：'+cixinglist+'。')
    time.sleep(2)
    print('其中，我判断'+newwords[0]+'是一个'+dict[cixing[0]]+'，你问我的是它的相关词汇有哪些对吗？')
    url='http://ictclas.nlpir.org/nlpir/index6/getWord2Vec.do'
    data={'content': newwords[0]}
    r = requests.post(url,data)
    other=json.loads(r.text)
    time.sleep(1)
    print ('\n我想了想和“'+newwords[0]+'”相关的词汇，至少还有：\n')
    time.sleep(1)
    f=0
    for i in other['w2vlist']:
        f=f+1
        word2 = i.split(',')
        print ('('+str(f)+')'+word2[0]+'，其相关度为'+word2[1])
        time.sleep(1)
user1 = input('''
现在，你已经解锁我的所有功能，可以自由聊天啦！我还有什么可以帮助你的吗？
回复内容，然后敲回车键！
>''')
#以上为分词部分

time.sleep(1)
import requests,json
userid = input('填入你的userid，自己的机器人的话可以随便填一个数字，例如101:')
# 你可以理解为你与图灵机器人之间的暗号，机器人通过这个id来确认你的身份
apikey = input('填入你的机器人apikey，注册机器人之后可以获得:')
# apikey 可以理解为是机器人的身份证号码，是识别机器人的标识
question1 = ''
# 通过条件判断来开启循环
while question1 != 'N':
    question = input('请输入你的问题')
    # 你需要问机器人的问题
    tulingdata1 = json.dumps({
        "perception": {
            "inputText": {
                "text": question
            },

        },
        "userInfo": {
            "apiKey": apikey,
            "userId":userid
        }
    })
    # 图灵机器人需要上传的数据，在接口文档中可以找到，这里选择了两个必须要的参数
    robot1 = requests.post('http://openapi.tuling123.com/openapi/api/v2',tulingdata1)
    # 图灵机器人的接口链接以及需要上传的数据，在接口文档中可以找到
    jsrobot1 = json.loads(robot1.text)['results'][0]['values']['text']
    # 机器人返回的结果是一个多重嵌套的字典，把字典中结果的部分获取出来
    print(jsrobot1)
    # 把结果打印出来
    question1 = input('是否继续询问呢,回复Y/N')
    #判断是否继续询问
print('下次见！')
#以上是接入图灵机器人部分





————————————————————————————————————————————————————————————————————————————————————————————————————————



自己完整地写出抓取电影下载链接的程序，并用input()函数对它进行优化。



import requests,bs4
#引用requests和bs4（BeautifulSoup4的缩写）,如果没有安装bs4，可以使用pip install beautifulsoup4下载。
from urllib.request import quote
#quote函数，可以帮我们把内容转为标准的url格式，作为网址的一部分打开。
movie = input('请输入你想要看的电影：')
gbkmovie=movie.encode('gbk')
#将汉字，用gbk格式编码，赋值给gbkmovie。
urlmovie = 'http://s.ygdy8.com/plus/so.php?kwtype=0&searchtype=title&keyword='+quote(gbkmovie)
#将gbk格式的内容，转为url，然后和前半部分的网址拼接起来。
res =requests.get(urlmovie)
#下载水形物语的搜索页面
bsmovie = bs4.BeautifulSoup(res.text,'html.parser')
#解析网页。
link = bsmovie.select('.co_content8 b a')
#查找目标。
finallink = 'http://www.ygdy8.com' + link[0].get('href')
#得到电影下载页的地址。
xiazai = requests.get(finallink).content.decode('gbk')
#使用requests模块，拿到电影下载页的源代码。使用content方法，拿到bytes数据，再进行decode，此时xiazai是字符串。
bsxiazai = bs4.BeautifulSoup(xiazai,'html.parser')
#解析网页。因为此时的xiazai已经是字符串，所以不需要加text。
download = bsxiazai.select('table tbody tr a')
#查找目标。
for x in download:
    print (x.get('href'))




————————————————————————————————————————————————————————————————————————————————————————————————————————



借助副本学习pyperclip和webbrowser模块的用法，学习如何双击运行程序的方法，实现一键下载电影。
注：网页系统不支持pyperclip和webbrowser模块，该挑战需要你在自己的本地电脑上完成。在此你只需要print('我已完成该挑战')，执行并提交即可。



《pyperclip和webbrowser模块》：https://shimo.im/docs/t1HAyUMCp6QR3Fv3/




from urllib.request import quote
#quote函数，可以帮我们把内容转为标准的url格式，作为网址的一部分打开
import webbrowser,pyperclip,requests,bs4
movie = pyperclip.paste()
#剪切板的内容，赋值给movie
gbkmovie=movie.encode('gbk')
#将汉字，用gbk格式编码，赋值给gbkmovie
urlmovie = quote(gbkmovie)
res =requests.get('http://s.ygdy8.com/plus/so.php?kwtype=0&searchtype=title&keyword='+urlmovie)
bsmovie = bs4.BeautifulSoup(res.text,'html.parser')
link = bsmovie.select('.co_content8 b a')
finallink = 'http://www.ygdy8.com' + link[0].get('href')
xiazai = requests.get(finallink)
gbkxiazai = xiazai.content.decode('gbk')
bsxiazai = bs4.BeautifulSoup(gbkxiazai,'html.parser')
download = bsxiazai.select('table tbody tr a')

if len(download)==1:
    lastlink=(download[0].get('href'))
    pyperclip.copy(lastlink)
    提示=input('下载链接已复制进剪切板中，打开迅雷点击“新建任务”，就好啦！点击enter退出')
else:
    lastlink=(download[1].get('href'))
    webbrowser.open(lastlink)
    pyperclip.copy(download[0].get('href'))  
    提示=input('如果种子不太好下载，打开迅雷点击“新建任务”，就好啦！点击enter退出')





————————————————————————————————————————————————————————————————————————————————————————————————————————



爬取豆瓣电影Top 250的名单，及其评分。'https://movie.douban.com/top250'


import requests,bs4,time
def printlist(url):
#爬取网页上的电影名单
    list = requests.get(url)
    bslist = bs4.BeautifulSoup(list.text,'html.parser')
    for x in range(25):
    #每页有25个电影
        movie = bslist.select('.grid_view li')[x]
        #查找了当前页面所有的电影，是一个list，list里的第[x]个元素。
        bsmovie = bs4.BeautifulSoup(str(movie),'html.parser')
        #movie是tag对象，但str(movie)就可以作为字符串了。
        num_movie = bsmovie.select('em')
        title_movie = bsmovie.select('a .title')
        mark_movie = bsmovie.select('.rating_num')
        inq_movie = bsmovie.select('.inq')
        print(num_movie[0].getText()+'. '+title_movie[0].getText()+'——'+mark_movie[0].getText()+'分')
        #序号，电影名，评分
        if len(inq_movie) != 0:
            print('推荐语：'+inq_movie[0].getText()+'\n\n')
        #推荐语
def fanye(num):
#写一个翻页的函数，参数是你想查询的电影总数
    page = int(num/25)
    #豆瓣电影每页显示25个，所有相除得到页数
    #除法得到的结果是浮点数，要用int()转换为整数才能range()
    for y in range(page):
        url = 'https://movie.douban.com/top250?start='+str(y*25)
        #这是电影排行榜网址的组成形式
        printlist(url)
        #调用printlist函数
        time.sleep(2)
        #休息两秒钟，防止被反爬虫
num = int(input('你想要输出多少个电影名单？请输入25的整数倍：'))
fanye(num)
#执行程序






————————————————————————————————————————————————————————————————————————————————————————————————————————




将豆瓣电影Top250爬虫，和下载电影的爬虫结合，获取到所有电影的下载链接。



import requests,bs4,time
from urllib.request import quote
text = str()
def movielink(movie):
    gbkmovie=movie.encode('gbk')
    #将汉字，用gbk格式编码，赋值给gbkmovie
    urlmovie = quote(gbkmovie)
    try:
    #阳光电影是一个小网站，并不稳定，批量执行程序容易报错终止，所以加一个try语句
        res =requests.get('http://s.ygdy8.com/plus/so.php?kwtype=0&searchtype=title&keyword='+urlmovie)
        bsmovie = bs4.BeautifulSoup(res.text,'html.parser')
        link = bsmovie.select('.co_content8 b a')
        if len(link)==2:
            return '这个电影暂时没有下载资源，不好意思奥～'
        else:
            finallink = 'http://www.ygdy8.com' + link[0].get('href')
            xiazai = requests.get(finallink)
            gbkxiazai = xiazai.content.decode('gbk')
            bsxiazai = bs4.BeautifulSoup(gbkxiazai,'html.parser')
            download = bsxiazai.select('table tbody tr a')
            if len(download)==1:
                return '电影下载链接：\n'+download[0].get('href')
            else:
                return '电影下载链接：\n'+'【1】'+download[1].get('href')+'\n【2】'+download[0].get('href')
    except:
        return '在查找这个电影的下载链接时发生了诡异的报错，所以我推荐你自己寻找它的下载链接。'
def printlist(url):
#爬取网页上的电影名单
    global text
    #这里，涉及到了一个关于函数的知识点，全局变量和局部变量。你可以搜索这个知识
    #这句代码意思是：在函数printlist()内，变量text和函数外的变量text是同个
    list = requests.get(url)
    bslist = bs4.BeautifulSoup(list.text,'html.parser')
    for x in range(25):
    #每页有25个电影
        movie = bslist.select('.grid_view li')[x]
        #查找了当前页面所有的电影，是一个list，list里的第[x]个元素。
        bsmovie = bs4.BeautifulSoup(str(movie),'html.parser')
        #movie是tag对象，但str(movie)就可以作为字符串了。
        num_movie = bsmovie.select('em')
        title_movie = bsmovie.select('a .title')
        mark_movie = bsmovie.select('.rating_num')
        inq_movie = bsmovie.select('.inq')
        link_movie = movielink(title_movie[0].getText())
        if len(inq_movie) != 0:
            text = text+num_movie[0].getText()+'. '+title_movie[0].getText()+'——'+mark_movie[0].getText()+'分\n推荐语：'+inq_movie[0].getText()+'\n'+link_movie+'\n\n'
        else:
            text = text+num_movie[0].getText()+'. '+title_movie[0].getText()+'——'+mark_movie[0].getText()+'分\n推荐语：'+'\n'+link_movie+'\n\n'

def fanye(num):
#写一个翻页的函数，参数是你想查询的电影总数
    page = int(num/25)
    #豆瓣电影每页显示25个，所有相除得到页数
    #除法得到的结果是浮点数，要用int()转换为整数才能range()
    for y in range(page):
        url = 'https://movie.douban.com/top250?start='+str(y*25)
        #这是电影排行榜网址的组成形式
        printlist(url)
        #调用printlist函数
        time.sleep(2)
        #休息两秒钟，防止被反爬虫
num = int(input('你想要输出多少个电影名单？请输入25的整数倍：'))
fanye(num)
#执行爬虫，此时text内有了内容
print(text)


————————————————————————————————————————————————————


（注：1，不要将账号密码写进代码，而是用input()函数输入，这样就不会被系统记录。2，我们承诺不存储用户的账户信息，但如果你放心不下，可在自己的本地电脑上完成该挑战。）



import smtplib
from email.mime.text import MIMEText
from email.header import Header
qqmail = smtplib.SMTP_SSL('smtp.qq.com',465)
#以上，登录服务器
account = input('请输入你的QQ邮箱：')
password = input('请输入你的邮箱密码：')
qqmail.login(account,password)
#以上，是登录邮箱
theme = input('请输入邮件标题：')
text = input('请输入邮件正文，使用<br>换行：')
recipient = input('请输入收件人邮箱，多个发件人使用空格隔开：')
recipient = recipient.split()
sender = input('请输入发件人昵称（可跳过）：')
#以上，是输入内容
message = MIMEText(text,'plain','utf-8')
message['Subject'] = Header(theme,'utf-8')
message['From'] = Header(sender,'utf-8')
#以上，是一波转换操作
try:
    qqmail.sendmail(account,recipient,message.as_string())
except:
    print('对不起，发送失败请重试！')
#以上，是发送
qqmail.quit()
#以上，是退出



————————————————————————————————————————————————————————————————————————————————————————————————————————



challenge 1：举一反三
1. （在本地电脑上完成，不提交）学习wxpy模块的用法，使用Python给自己喜欢的人发一条微信消息。http://wxpy.readthedocs.io/zh/latest/ 
2. （需要提交）写一个能够批量发送邮件的程序，每个用户收到的邮件都不同。用户邮箱，邮件主题，邮件内容数据都来自一个txt文档。 
在作业系统的文件夹里，我们给出了这个txt文档，文档里有11个邮箱，这11个邮箱都是我们收集来的废弃邮箱，所以大家可以随便测试。你可以利用读写文件的知识，提取里面的内容。下面，是一个文档预览。
注意：发送邮件的速度太快，会触发QQ邮箱的反垃圾系统，暂时限制你的邮件功能。
有两种解决方案：
（1）一次别发太多，至多5个。
（2）你可以使用time.sleep()函数，让程序每发完一个邮件，就休息一会，再发下一个。经测试，15秒是一个可接受的数字。
（注：1，不要将账号密码写进代码，而是用input()函数输入，这样就不会被系统记录。2，我们承诺不存储用户的账户信息，但如果你放心不下，可在自己的本地电脑上完成该挑战。）
以下是数据：



243816508@qq.com
你的python考试成绩
100分
wjy86701178@163.com
你的python考试成绩
99分
wjy84283241@163.com
你的python考试成绩
98分
wjy842832411@126.com
你的python考试成绩
97分
1.zhangyang00@163.com
你的python考试成绩
96分
13262574651@163.com
你的python考试成绩
95分
13262786918@163.com
你的python考试成绩
94分
17093886430@163.com
你的python考试成绩
93分
ymz3017@163.com
你的python考试成绩
92分
17093894917@163.com
你的python考试成绩
91分
ymz4017@163.com
你的python考试成绩
90分




参考答案：
from wxpy import *
bot = Bot()
my_girl = bot.friends().search('酱酱')
my_girl.send('酱酱，你真可爱！')


import smtplib,time
from email.mime.text import MIMEText
from email.header import Header
qqmail = smtplib.SMTP_SSL('smtp.qq.com',465)
#以上，登录服务器
account = input('请输入你的QQ邮箱：')
password = input('请输入你的邮箱密码：')
sender = input('请输入发件人昵称（可跳过）：')
qqmail.login(account,password)
#以上，是登录邮箱
f = open('chengji.txt','r',encoding='utf-8')
read = f.readlines()
num = int(len(read)/3)
for x in range(num):
    recipient = read[x*3]
    theme = read[x*3+1]
    text = read[x*3+2]
    #以上，是输入内容
    message = MIMEText(text,'plain','utf-8')
    message['Subject'] = Header(theme,'utf-8')
    message['From'] = Header(sender,'utf-8')
    #以上，是一波转换操作
    try:
        qqmail.sendmail(account,recipient,message.as_string())
        print('成功')
        time.sleep(15)
    except:
        print('对不起，发送失败请重试！')
        time.sleep(15)
    #以上，是发送
qqmail.quit()
#以上，是退出



————————————————————————————————————————————————————————————————————————————————————————————————————————



assignment 1：融会贯通Plus




import requests,json

link = requests.get('https://www.shanbay.com/api/v1/vocabtest/category/')
js_link = json.loads(link.text)
bianhao = int(input('''请输入你选择的词库编号，按Enter确认
1，GMAT  2，考研  3，高考  4，四级  5，六级
6，英专  7，托福  8，GRE  9，雅思  10，任意
>'''))
ciku = js_link['data'][bianhao-1][0]

test = requests.get('https://www.shanbay.com/api/v1/vocabtest/vocabularies/?category='+ciku)
words = json.loads(test.text)
danci = []
#新增一个list，用于统计用户认识的单词
words_knows = []
not_knows = []
print ('测试现在开始。如果你认识这个单词，请输入Y，否则直接敲Enter：')
n=0
for x in words['data']:
    n=n+1
    print ("\n第"+str(n)+'个：'+x['content'])
    #加一个\n，用于换行。
    answer = str.upper(input('你认识这个单词吗？Y/N'))
    if answer == 'Y':
        danci.append(x['content'])
        #把用户认识的单词，追加进danci这个list。
        words_knows.append(x)
    else:
        not_knows.append(x)

print ('\n在上述'+str(len(words['data']))+'个单词当中，有'+str(len(danci))+'个是你觉得自己认识的，它们是：')
print(danci)


print ('现在我们来检测一下，你有没有真正掌握它们：')
wrong_words = []
right_num = 0
for y in words_knows:
    print('\n\n'+'A:'+y['definition_choices'][0]['definition'])
    #我们改用A、B、C、D，不再用rank值，下同
    print('B:'+y['definition_choices'][1]['definition'])
    print('C:'+y['definition_choices'][2]['definition'])
    print('D:'+y['definition_choices'][3]['definition'])
    xuanze = str.upper(input('请选择单词\"'+y['content']+'\"的正确翻译（填写字母即可）：'))
    while(xuanze not in ('A','B','C','D')):
        xuanze = str.upper(input('输入错误，请重新输入：'))
    dic = {'A':y['definition_choices'][0]['rank'],'B':y['definition_choices'][1]['rank'],'C':y['definition_choices'][2]['rank'],'D':y['definition_choices'][3]['rank']}
    #我们创建一个字典，搭建起A、B、C、D和四个rank值的映射关系。
    if dic[xuanze] == y['rank']:
    #此时dic[xuanze]的内容，其实就是rank值，此时的代码含义已经和之前的版本相同了。
        right_num += 1
    else:
        wrong_words.append(y)
print ('现在，到了公布成绩的时刻:')
print ('在'+str(len(words['data']))+'个'+js_link['data'][bianhao-1][1]+'词汇当中，你认识其中'+str(len(danci))+'个，实际掌握'+str(right_num)+'个，错误'+str(len(wrong_words))+'个。')
#这是句蛮复杂的话，对照前面的代码和json文件你才能理解它。一个运行示例是：在50个高考词汇当中，你认识其中30个，实际掌握25个，错误5个。

save = input ('是否打印并保存你的错词集？填入Y或N： ')
#询问用户，是否要打印并保存错题集。
if save == 'Y':
#如果用户说是：
    f = open('错题集.txt', 'a+')
    #在当前目录下，创建一个错题集.txt的文档。
    print ('你记错的单词有：')
    f.write('你记错的单词有：\n')
    #写入"你记错的单词有：\n"
    m=0
    for z in wrong_words:
    #启动一个循环，循环的次数等于，用户的错词数：
        m=m+1
        print (z['content'])
        #打印每一个错词。
        f.write(str(m+1) +'. '+ z['content']+'\n')
        #写入序号，写入错词。
    print ('你不认识的单词有：')
    f.write('你没记住的单词有：\n')
    #写入"你没记住的单词有：\n"
    s=0
    for x in not_knows:
    #启动一个循环，循环的次数等于，用户不认识的单词数。
        print (x['content'])
        #打印每一个不认识的单词。
        f.write(str(s+1) +'. '+ x['content']+'\n')
        #写入序号，写入用户不认识的词汇。
    print ('错词和没记住的词已保存至当前文件目录下，下次见！')
    #告诉用户，文件已经保存好。
else:
#如果用户不想保存：
    print('下次见！')
    #输出“下次见！”



————————————————————————————————————————————————————————————————————————————————————————————————————————



【题目】 改良代码，满足用户挑剔的需求：
1. 用户体验过程中，很多该换行的地方没有换行，看起来很痛苦。
2. 用户表示选择了题库之后，等待的时间过长，希望更快一些出题目（提示：考虑用字典来实现词库选择，而不是用爬虫）。
3. 用户表示有时候字出得太快，还没反应过来就刷出来很多文字，需要往前翻阅读文字（提示：考虑使用sleep函数降低程序运行速度）。
4. 用户表示错题集是很好的功能没错，但是里面只有错词，没有错词的翻译，不方便记忆。所以，可不可以加上翻译呢？

以下两个功能为课外挑战（此处不做展示）：<br>

5. 用户表示在测试结束后，扇贝网会返回一个用户词汇量的估值，希望你的产品也能有（提示：这里要用post了）。
6. 借助图形界面的一些库，如：Tk/Qt/wxWidgets/GTK，你可以把这些代码，改造成有图形交互的程序，而非现在的命令行。去试试看！





import requests,json,time

d = {"1":"GMAT", "2":"NGEE", "3":"NCEE", "4":"CET4", "5":"CET6", "6":"TEM", "7":"TOEFL", "8":"GRE", "9":"IELTS", "10":"NONE"}

bianhao = input('''请输入你选择的词库编号，按Enter确认
1，GMAT  2，考研  3，高考  4，四级  5，六级
6，英专  7，托福  8，GRE  9，雅思  10，任意
>''')
#这里用自己创建的字典，代替了抓取的json文件。
test = requests.get('https://www.shanbay.com/api/v1/vocabtest/vocabularies/?category='+d[bianhao])
words = json.loads(test.text)
danci = []
words_knows = []
word_ranks = []
#增加了一个list，用来统计每个单词的正确rank值，后面会用到的。
not_knows = []
print ('\n测试现在开始。如果你认识这个单词，请输入Y，否则直接敲Enter：')
time.sleep(1)
#使用sleep函数，让程序暂停运行，给用户阅读和思考的时间，下同。
n=0
for x in words['data']:
    n=n+1
    word_ranks.append(x['rank'])
    #把单词正确的rank值，记录下来。后面在post时要用的。
    print ("\n第"+str(n)+'个：'+x['content'])
    #加一个\n，用于换行。
    answer = str.upper(input('你认识这个单词吗？Y/N'))
    if answer == 'Y':
        danci.append(x['content'])
        #把用户认识的单词，追加进danci这个list。
        words_knows.append(x)
    else:
        not_knows.append(x)
print ('\n在上述'+str(len(words['data']))+'个单词当中，有'+str(len(danci))+'个是你觉得自己认识的，它们是：')
time.sleep(1)
print(danci)
time.sleep(1)
print ('现在我们来检测一下，你有没有真正掌握它们：')
time.sleep(1)
wrong_words = []
right_num = 0
right_ranks = []
#创建一个list，用来记录用户答对的rank值。
for y in words_knows:
    print('\n\n'+'A:'+y['definition_choices'][0]['definition'])
    #我们改用A、B、C、D，不再用rank值，下同
    print('B:'+y['definition_choices'][1]['definition'])
    print('C:'+y['definition_choices'][2]['definition'])
    print('D:'+y['definition_choices'][3]['definition'])
    xuanze = str.upper(input('请选择单词\"' + y['content'] + '\"的正确翻译（填写字母即可）：'))
    while (xuanze not in ('A', 'B', 'C', 'D')):
        xuanze = str.upper(input('输入错误，请重新输入：'))
    dic = {'A':y['definition_choices'][0]['rank'],'B':y['definition_choices'][1]['rank'],'C':y['definition_choices'][2]['rank'],'D':y['definition_choices'][3]['rank']}
    #我们创建一个字典，搭建起A、B、C、D和四个rank值的映射关系。
    if dic[xuanze] == y['rank']:
    #此时dic[xuanze]的内容，其实就是rank值，此时的代码含义已经和之前的版本相同了。
        right_num += 1
        right_ranks.append(y['rank'])
        #如果用户答对了，就把这个单词的rank值记录下来。

    else:
        wrong_words.append(y)


print(right_ranks)
right_ranks = ','.join('%s' %id for id in right_ranks)
#post上传的是字符串，而不是list。所以要转换。
word_ranks = ','.join('%s' %id for id in word_ranks)
#post上传的是字符串，而不是list。所以要转换。

post_data = {'category':d[bianhao],'phase':'','right_ranks':right_ranks,'word_ranks':word_ranks}
#制作用来post的数据，包含词库，一个空的phase，用户答对的单词rank值，所有正确的rank值。为什么会是这四个？请复习上节课的内容。
post_result = requests.post('https://www.shanbay.com/api/v1/vocabtest/vocabularies/',post_data)
#post需要两个参数，一个是网址，一个是用来post的数据。返回的，是一个Response对象。
result = json.loads(post_result.text)

print ('\n现在，到了公布成绩的时刻:')
print ('在'+str(len(words['data']))+'个'+bianhao+'词汇当中，你认识其中'+str(len(danci))+'个，实际掌握'+str(right_num)+'个，错误'+str(len(wrong_words))+'个。')
time.sleep(1)
print ('你的最终得分是：'+str(result['data']['vocab']),'分！'+result['data']['comment'])
if wrong_words != [] or not_knows != []:
#下面会是一系列复杂的循环/判断互相嵌套，需要你多点耐心阅读和理解。
    save = input ('是否打印并保存你的错词集？填入Y或N： ')
    if save == 'Y':
        print ('\n你记错的单词有：')
        time.sleep(1)
        a = 0
        for m in wrong_words:
            a=a+1
            print (str(a) +'. '+ m['content'])
        print ('\n你不认识的单词有：')
        time.sleep(1)
        b=0
        for s in not_knows:
            b=b+1
            print (str(b) +'. '+ s['content'])
        print ('\n错词和没记住的词已保存至当前文件目录下，下次见！')
        with open ('错题集.txt','a+') as f:
            f.write('你记错的单词有：\n')
            a=0
            for m in wrong_words:
                a=a+1
                f.write(str(a) +'. '+ m['content']+'\n')
                for m1 in range(4):
                    if m['definition_choices'][m1]['rank'] == m['rank']:
                        f.write(m['definition_choices'][m1]['definition']+'\n\n')
            f.write('你没记住的单词有：\n')
            b=0
            for s in not_knows:
                b=b+1
                f.write(str(b) +'. '+ s['content']+'\n')
                for s1 in range(4):
                    if s['definition_choices'][s1]['rank'] == s['rank']:
                        f.write(s['definition_choices'][s1]['definition']+'\n\n')
    else:
        print ('\n下次见！')
input('\n本次测试到此结束，点击Enter退出')





————————————————————————————————————————————————————————————————————————————————————————————————————————



利用你已经学过的知识，设计一个文字冒险游戏。
注：以下是狼人之夜代码节选，完整代码详见：https://share.weiyun.com/59kPjFe
本代码，需在Python3环境下运行。



import time
#引用时间模块。
superdict = {}
#定义了一个字典，字典里的内容是页码对应故事。此处省略。
print('''古代欧洲，爆发瘟疫，人们纷纷死去，一个叫做亚历山大·柯文纳斯的军头也感染了疾病，但只有他一个人活了下来。亚历山大的孩子一共有3位，不幸的是其中两位－马库斯与威廉，一个被蝙蝠咬伤，另一个却狼咬伤，只有一位作为普通人。两个兄弟由于病毒产生变异，一位成为吸血鬼的始祖，另一位成为狼人的始祖。从此狼人和吸血鬼便在欧洲流传开来……
许多年以后……''')
#就是最简单的print。
time.sleep(3)
#程序休息3秒，再运行。
num=input('''
回复1开始《狼人之夜》游戏。
>''')
#启动游戏。
goodend = [74,77,22,49]
#这些页码，是好的结局。
badend = [52,75,69,33,75,63,62,61,35]
#这些页码，是坏的结局。
game=[]
#创建一个空列表，用来记录用户的选择。
time.sleep(1)
#程序休息1秒。
while True:
#创建一个循环。
    game.append(num)
    #记录用户输入的页码。
    print(superdict['page'+num])
    #打印出用户选择页码，对应的内容。
    time.sleep(3)
    #休息3秒。
    if int(num) in goodend:
    #如果用户输入的页码，是好结局所在页码，那么：
        f = open('D:\\游戏记录.txt','a+')
        #在电脑D盘的根目录下，创建一个txt文档。
        for x in game:
        #遍历游戏记录。
            f.write(superdict['page'+str(x)]+'\n\n')
            #写入故事。
            f.close
            #关闭文档。
        input('''luck Dog!
恭喜你，成功通关本游戏。
游戏记录已保存至D盘根目录下！
点击Enter即可退出游戏~
注：游戏脚本出自《狼人之夜》。
原作者为汤姆·B·斯通（Tom B. Stone）。
>''')
        break
        #结束循环
    if int(num) in badend:
    #类比，好结局那部分的代码。
        f = open('D:\\游戏记录.txt','a+')
        for x in game:
            f.write(superdict['page'+str(x)]+'\n\n')
            f.close
        input('''Bad Ending!
恭喜你，成功通关本游戏。
游戏记录已保存至D盘根目录下！
点击Enter即可退出游戏~
注：游戏脚本出自《狼人之夜》。
原作者为汤姆·B·斯通（Tom B. Stone）。
>''')
        break
        #跳出循环。
    num = input('请输入数字编码：')
    #如果没触发结局，让用户继续输入页码。




————————————————————————————————————————————————————————————————————————————————————————————————————————




抓取携程网站上，关于深圳欢乐谷的前三页评论：http://you.ctrip.com/sight/Shenzhen26/13720.html

【提示】
评论数据藏身于XHR中，但是数据需要使用BeautifulSoup模块解析。



import requests,bs4,time
url = 'http://you.ctrip.com/destinationsite/TTDSecond/SharedView/AsynCommentView'
#在XHR中找到存储景点评论的url
for x in range(3):
    #获取前三页内容，利用控制页数的参数进行循环
    head={'User-Agent':'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36'}
    #利用请求头进行反爬
    data = {
'poiID':'79101',
'districtId':'26',
'districtEName':'Shenzhen',
'pagenow':str(x+1),
#参数pagenow控制的当前评论页数
'order':'3.0',
'star':'0',
'tourist':'0.0',
'resourceId':'13720',
'resourcetype':'2'}
    r = requests.post(url,data,headers=head)
    bsr = bs4.BeautifulSoup(r.text,'html.parser')
    pinglun = bsr.select('.heightbox')
    for y in range(len(pinglun)):
        print(str(10*x+y+1)+'.'+pinglun[y].getText()+'\n\n\n')




————————————————————————————————————————————————————————————————————————————————————————————————————————



【题目】
把发邮件的代码，和爬取豆瓣电影top250的代码相结合，写一个程序，自动爬取豆瓣电影的名单，并把爬取到的结果发送到自己的邮箱。如果可以，你还能连同电影的下载链接，一并发送。


import requests,bs4,time,smtplib
from email.mime.text import MIMEText
from email.header import Header
from urllib.request import quote
text = str()

def movielink(movie):
    gbkmovie=movie.encode('gbk')
    #将汉字，用gbk格式编码，赋值给gbkmovie
    urlmovie = quote(gbkmovie)
    try:
    #阳光电影是一个小网站，并不稳定，批量执行程序容易报错终止，所以加一个try语句
        res =requests.get('http://s.ygdy8.com/plus/so.php?kwtype=0&searchtype=title&keyword='+urlmovie)
        bsmovie = bs4.BeautifulSoup(res.text,'html.parser')
        link = bsmovie.select('.co_content8 b a')
        if len(link)==2:
            return '这个电影暂时没有下载资源，不好意思奥～'
        else:
            finallink = 'http://www.ygdy8.com' + link[0].get('href')
            xiazai = requests.get(finallink)
            gbkxiazai = xiazai.content.decode('gbk')
            bsxiazai = bs4.BeautifulSoup(gbkxiazai,'html.parser')
            download = bsxiazai.select('table tbody tr a')
            if len(download)==1:
                return '电影下载链接：\n'+download[0].get('href')
            else:
                return '电影下载链接：\n'+'【1】'+download[1].get('href')+'\n【2】'+download[0].get('href')
    except:
        return '在查找这个电影的下载链接时发生了诡异的报错，所以我推荐你自己寻找它的下载链接。'
def printlist(url):
#爬取网页上的电影名单
    global text
    #这里，涉及到了一个关于函数的知识点，全局变量和局部变量。你可以搜索这个知识
    #这句代码意思是：在函数printlist()内，变量text和函数外的变量text是同个
    list = requests.get(url)
    bslist = bs4.BeautifulSoup(list.text,'html.parser')
    for x in range(25):
    #每页有25个电影
        movie = bslist.select('.grid_view li')[x]
        #查找了当前页面所有的电影，是一个list，list里的第[x]个元素。
        bsmovie = bs4.BeautifulSoup(str(movie),'html.parser')
        #movie是tag对象，但str(movie)就可以作为字符串了。
        num_movie = bsmovie.select('em')
        title_movie = bsmovie.select('a .title')
        mark_movie = bsmovie.select('.rating_num')
        inq_movie = bsmovie.select('.inq')
        link_movie = movielink(title_movie[0].getText())
        if len(inq_movie) != 0:        
            text = text+num_movie[0].getText()+'. '+title_movie[0].getText()+'——'+mark_movie[0].getText()+'分\n推荐语：'+inq_movie[0].getText()+'\n'+link_movie+'\n\n'
        else:
            text = text+num_movie[0].getText()+'. '+title_movie[0].getText()+'——'+mark_movie[0].getText()+'分\n推荐语：'+'\n'+link_movie+'\n\n'
        #编写了邮件正文
def fanye(num):
#写一个翻页的函数，参数是你想查询的电影总数
    page = int(num/25)
    #豆瓣电影每页显示25个，所有相除得到页数
    #除法得到的结果是浮点数，要用int()转换为整数才能range()
    for y in range(page):
        url = 'https://movie.douban.com/top250?start='+str(y*25)
        #这是电影排行榜网址的组成形式
        printlist(url)
        #调用printlist函数
        time.sleep(2)
        #休息两秒钟，防止被反爬虫
account = input('请输入你的QQ邮箱：')
password = input('请输入你的邮箱密码：')
theme = input('请输入邮件标题：')
recipient = input('请输入收件人邮箱，多个发件人使用空格隔开：')
recipient = recipient.split()
sender = input('请输入发件人昵称（可跳过）：')
#以上，是输入内容
num = int(input('你想要输出多少个电影名单？请输入25的整数倍：'))
fanye(num)
#执行爬虫，此时text内有了内容
qqmail = smtplib.SMTP_SSL('smtp.qq.com',465)
qqmail.ehlo()
#以上，登录服务器
qqmail.login(account,password)
#以上，是登录邮箱
message = MIMEText(text,'plain','utf-8')
message['Subject'] = Header(theme,'utf-8')
message['From'] = Header(sender,'utf-8')
#以上，是一波转换操作
try:
    qqmail.sendmail(account,recipient,message.as_string())
except:
    print('对不起，发送失败请重试！')
#以上，是发送
qqmail.quit()
#以上，是退出



————————————————————————————————————————————————————————————————————————————————————————————————————————







